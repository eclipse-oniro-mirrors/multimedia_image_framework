/*
 * Copyright (C) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "image_compressor.h"

#include <cmath>
#include <securec.h>

#include "abs_image_encoder.h"
#include "hilog/log.h"
#include "log_tags.h"

namespace OHOS {
namespace Media {
using namespace OHOS::HiviewDFX;
namespace {
constexpr OHOS::HiviewDFX::HiLogLabel LABEL = { LOG_CORE, LOG_TAG_DOMAIN_ID_PLUGIN, "ImageCompressor"};
constexpr uint8_t BIT_SHIFT_8BITS = 8;
constexpr uint8_t BIT_SHIFT_16BITS = 16;
constexpr uint8_t BIT_SHIFT_24BITS = 24;
constexpr uint8_t BYTES_MASK = 0xFF;
constexpr uint8_t STRIDE_RGBA_LOG2 = 2;
constexpr uint8_t GLOBAL_WH_NUM_CL = 2;

constexpr uint8_t PARTITION_COUNT_2 = 2;
constexpr uint8_t PARTITION_COUNT_3 = 3;
constexpr uint8_t PARTITION_COUNT_4 = 4;
}

const char *g_programSource = R"(
#define DIM 4
#define BLOCK_SIZE 16 // DIM * DIM
#define X_GRIDS 4
#define Y_GRIDS 4
#define SMALL_VALUE 0.00001f
#define BLOCK_MAX_WEIGHTS 64
#define BLOCK_MAX_WEIGHTS_2PLANE 32
#define WEIGHTS_PLANE2_OFFSET BLOCK_MAX_WEIGHTS_2PLANE
#define CEM_LDR_RGB_DIRECT 8u
#define CEM_LDR_RGB_BASE_OFFSET 9u
#define CEM_LDR_RGBA_DIRECT 12u
#define CEM_LDR_RGBA_BASE_OFFSET 13u

#define    QUANT_2 0
#define    QUANT_3 1
#define    QUANT_4 2
#define    QUANT_5 3
#define    QUANT_6 4
#define    QUANT_8 5
#define    QUANT_10 6
#define    QUANT_12 7
#define    QUANT_16 8
#define    QUANT_20 9
#define    QUANT_24 10
#define    QUANT_32 11
#define    QUANT_40 12
#define    QUANT_48 13
#define    QUANT_64 14
#define    QUANT_80 15
#define    QUANT_96 16
#define    QUANT_128 17
#define    QUANT_160 18
#define    QUANT_192 19
#define    QUANT_256 20
#define    QUANT_MAX 21

#define WEIGHT_QUANTIZE_NUM 32
#define COLOR_NUM 256

#define MAX_PARTITION_COUNT 4
#define PARTITION_COUNT 2

typedef struct {
    int partid;
    uint bitmaps[2];
} PartInfo;

int get_part(PartInfo* part_info, int i)
{
    if (i >= 32) {
        return 0;
    }
    return (int)(((*part_info).bitmaps[1] >> i) & 0x1u);
}

#define PARTITION_ORDER_MAX 5
#define WEIGHT_QUANTIZE_NUM 32
__constant short scramble_table[12 * WEIGHT_QUANTIZE_NUM] = {
    0, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0, 1, 2,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 5, 3, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 6, 8, 9, 7, 5, 3, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8, 2, 6, 10, 11, 7, 3, 9, 5, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8, 12, 16, 2, 6, 10, 14, 18, 19, 15, 11, 7, 3, 17, 13, 9, 5, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 8, 16, 2, 10, 18, 4, 12, 20, 6, 14, 22, 23, 15, 7, 21, 13, 5, 19,
    11, 3, 17, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31
};

__constant short weight_unquant[12 * WEIGHT_QUANTIZE_NUM] = {
    0, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 32, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 21, 43, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 16, 32, 48, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 12, 52, 25, 39,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 9, 18, 27, 37, 46, 55, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 7, 57, 14, 50, 21, 43, 28, 36,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 17, 47, 5, 59, 23, 41, 11, 53, 28, 36,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 8, 12, 17, 21, 25, 29, 35, 39, 43, 47, 52, 56, 60, 64,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 16, 48, 3, 61, 19, 45, 6, 58, 23, 41, 9, 55, 26, 38, 13, 51, 29, 35,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 64, 8, 56, 16, 48, 24, 40, 2, 62, 11, 53, 19, 45, 27, 37, 5, 59, 13, 51, 22, 42, 30, 34,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 34, 36, 38,
    40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64
};

__constant short integer_from_trits[243] = {
    0, 1, 2, 4, 5, 6, 8, 9, 10,
    16, 17, 18, 20, 21, 22, 24, 25, 26,
    3, 7, 15, 19, 23, 27, 12, 13, 14,
    32, 33, 34, 36, 37, 38, 40, 41, 42,
    48, 49, 50, 52, 53, 54, 56, 57, 58,
    35, 39, 47, 51, 55, 59, 44, 45, 46,
    64, 65, 66, 68, 69, 70, 72, 73, 74,
    80, 81, 82, 84, 85, 86, 88, 89, 90,
    67, 71, 79, 83, 87, 91, 76, 77, 78,

    128, 129, 130, 132, 133, 134, 136, 137, 138,
    144, 145, 146, 148, 149, 150, 152, 153, 154,
    131, 135, 143, 147, 151, 155, 140, 141, 142,
    160, 161, 162, 164, 165, 166, 168, 169, 170,
    176, 177, 178, 180, 181, 182, 184, 185, 186,
    163, 167, 175, 179, 183, 187, 172, 173, 174,
    192, 193, 194, 196, 197, 198, 200, 201, 202,
    208, 209, 210, 212, 213, 214, 216, 217, 218,
    195, 199, 207, 211, 215, 219, 204, 205, 206,

    96, 97, 98, 100, 101, 102, 104, 105, 106,
    112, 113, 114, 116, 117, 118, 120, 121, 122,
    99, 103, 111, 115, 119, 123, 108, 109, 110,
    224, 225, 226, 228, 229, 230, 232, 233, 234,
    240, 241, 242, 244, 245, 246, 248, 249, 250,
    227, 231, 239, 243, 247, 251, 236, 237, 238,
    28, 29, 30, 60, 61, 62, 92, 93, 94,
    156, 157, 158, 188, 189, 190, 220, 221, 222,
    31, 63, 127, 159, 191, 255, 252, 253, 254
};

#define QUANT_MAX 21
__constant int bits_trits_quints_table[QUANT_MAX * 3] = {
    1, 0, 0, // RANGE_2
    0, 1, 0, // RANGE_3
    2, 0, 0, // RANGE_4
    0, 0, 1, // RANGE_5
    1, 1, 0, // RANGE_6
    3, 0, 0, // RANGE_8
    1, 0, 1, // RANGE_10
    2, 1, 0, // RANGE_12
    4, 0, 0, // RANGE_16
    2, 0, 1, // RANGE_20
    3, 1, 0, // RANGE_24
    5, 0, 0, // RANGE_32
    3, 0, 1, // RANGE_40
    4, 1, 0, // RANGE_48
    6, 0, 0, // RANGE_64
    4, 0, 1, // RANGE_80
    5, 1, 0, // RANGE_96
    7, 0, 0, // RANGE_128
    5, 0, 1, // RANGE_160
    6, 1, 0, // RANGE_192
    8, 0, 0 // RANGE_256
};

__constant short integer_from_quints[125] = {
    0, 1, 2, 3, 4, 8, 9, 10, 11, 12, 16, 17, 18, 19, 20, 24, 25, 26, 27, 28, 5, 13, 21, 29, 6,
    32, 33, 34, 35, 36, 40, 41, 42, 43, 44, 48, 49, 50, 51, 52, 56, 57, 58, 59, 60, 37, 45, 53,
    61, 14,
    64, 65, 66, 67, 68, 72, 73, 74, 75, 76, 80, 81, 82, 83, 84, 88, 89, 90, 91, 92, 69, 77, 85,
    93, 22,
    96, 97, 98, 99, 100, 104, 105, 106, 107, 108, 112, 113, 114, 115, 116, 120, 121, 122, 123,
    124, 101, 109, 117, 125, 30,
    102, 103, 70, 71, 38, 110, 111, 78, 79, 46, 118, 119, 86, 87, 54, 126, 127, 94, 95, 62, 39,
    47, 55, 63, 31
};

__constant short color_quant_tables[21 * 256] = {
    // QUANT_2
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_3
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    // QUANT_4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    // QUANT_5
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    // QUANT_6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_8
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    // QUANT_10
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_12
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_16
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15,
    // QUANT_20
    0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
    16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 10, 10, 10, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
    19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 11, 11, 11, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 1, 1, 1, 1, 1, 1,
    // QUANT_24
    0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 10, 10, 10, 10, 10, 10, 10, 10, 10,
    10, 10, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 12, 12,
    12, 12, 12, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 14, 14, 14, 14, 14, 14, 14,
    14, 14, 14, 14, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
    23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 15, 15, 15, 15,
    15, 15, 15, 15, 15, 15, 15, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 5, 5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 11, 11,
    11, 11, 11, 11, 11, 11, 11, 11, 11, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1, 1, 1,
    // QUANT_32
    0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2,
    2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6,
    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10,
    10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
    12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13,
    14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
    18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19,
    19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
    21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23,
    23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
    25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
    27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
    29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
    // QUANT_40
    0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16,
    16, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 2, 2,
    2, 2, 2, 2, 10, 10, 10, 10, 10, 10, 10, 18, 18, 18, 18, 18,
    18, 26, 26, 26, 26, 26, 26, 26, 34, 34, 34, 34, 34, 34, 4, 4,
    4, 4, 4, 4, 4, 12, 12, 12, 12, 12, 12, 20, 20, 20, 20, 20,
    20, 20, 28, 28, 28, 28, 28, 28, 36, 36, 36, 36, 36, 36, 36, 6,
    6, 6, 6, 6, 6, 14, 14, 14, 14, 14, 14, 14, 22, 22, 22, 22,
    22, 22, 30, 30, 30, 30, 30, 30, 30, 38, 38, 38, 38, 38, 38, 38,
    39, 39, 39, 39, 39, 39, 39, 31, 31, 31, 31, 31, 31, 31, 23, 23,
    23, 23, 23, 23, 15, 15, 15, 15, 15, 15, 15, 7, 7, 7, 7, 7,
    7, 37, 37, 37, 37, 37, 37, 37, 29, 29, 29, 29, 29, 29, 21, 21,
    21, 21, 21, 21, 21, 13, 13, 13, 13, 13, 13, 5, 5, 5, 5, 5,
    5, 5, 35, 35, 35, 35, 35, 35, 27, 27, 27, 27, 27, 27, 27, 19,
    19, 19, 19, 19, 19, 11, 11, 11, 11, 11, 11, 11, 3, 3, 3, 3,
    3, 3, 33, 33, 33, 33, 33, 33, 33, 25, 25, 25, 25, 25, 25, 17,
    17, 17, 17, 17, 17, 17, 9, 9, 9, 9, 9, 9, 1, 1, 1, 1,
    // QUANT_48
    0, 0, 0, 16, 16, 16, 16, 16, 16, 32, 32, 32, 32, 32, 2, 2,
    2, 2, 2, 18, 18, 18, 18, 18, 18, 34, 34, 34, 34, 34, 4, 4,
    4, 4, 4, 4, 20, 20, 20, 20, 20, 36, 36, 36, 36, 36, 6, 6,
    6, 6, 6, 6, 22, 22, 22, 22, 22, 38, 38, 38, 38, 38, 38, 8,
    8, 8, 8, 8, 24, 24, 24, 24, 24, 24, 40, 40, 40, 40, 40, 10,
    10, 10, 10, 10, 26, 26, 26, 26, 26, 26, 42, 42, 42, 42, 42, 12,
    12, 12, 12, 12, 12, 28, 28, 28, 28, 28, 44, 44, 44, 44, 44, 14,
    14, 14, 14, 14, 14, 30, 30, 30, 30, 30, 46, 46, 46, 46, 46, 46,
    47, 47, 47, 47, 47, 47, 31, 31, 31, 31, 31, 15, 15, 15, 15, 15,
    15, 45, 45, 45, 45, 45, 29, 29, 29, 29, 29, 13, 13, 13, 13, 13,
    13, 43, 43, 43, 43, 43, 27, 27, 27, 27, 27, 27, 11, 11, 11, 11,
    11, 41, 41, 41, 41, 41, 25, 25, 25, 25, 25, 25, 9, 9, 9, 9,
    9, 39, 39, 39, 39, 39, 39, 23, 23, 23, 23, 23, 7, 7, 7, 7,
    7, 7, 37, 37, 37, 37, 37, 21, 21, 21, 21, 21, 5, 5, 5, 5,
    5, 5, 35, 35, 35, 35, 35, 19, 19, 19, 19, 19, 19, 3, 3, 3,
    3, 3, 33, 33, 33, 33, 33, 17, 17, 17, 17, 17, 17, 1, 1, 1,
    // QUANT_64
    0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
    4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8,
    8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12,
    12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16,
    16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,
    20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,
    24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,
    28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,
    32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,
    36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,
    40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,
    44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,
    47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51,
    51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55,
    55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59,
    59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63,
    // QUANT_80
    0, 0, 16, 16, 16, 32, 32, 32, 48, 48, 48, 48, 64, 64, 64, 2,
    2, 2, 18, 18, 18, 34, 34, 34, 50, 50, 50, 50, 66, 66, 66, 4,
    4, 4, 20, 20, 20, 36, 36, 36, 36, 52, 52, 52, 68, 68, 68, 6,
    6, 6, 22, 22, 22, 38, 38, 38, 38, 54, 54, 54, 70, 70, 70, 8,
    8, 8, 24, 24, 24, 24, 40, 40, 40, 56, 56, 56, 72, 72, 72, 10,
    10, 10, 26, 26, 26, 26, 42, 42, 42, 58, 58, 58, 74, 74, 74, 12,
    12, 12, 12, 28, 28, 28, 44, 44, 44, 60, 60, 60, 76, 76, 76, 14,
    14, 14, 14, 30, 30, 30, 46, 46, 46, 62, 62, 62, 78, 78, 78, 78,
    79, 79, 79, 79, 63, 63, 63, 47, 47, 47, 31, 31, 31, 15, 15, 15,
    15, 77, 77, 77, 61, 61, 61, 45, 45, 45, 29, 29, 29, 13, 13, 13,
    13, 75, 75, 75, 59, 59, 59, 43, 43, 43, 27, 27, 27, 27, 11, 11,
    11, 73, 73, 73, 57, 57, 57, 41, 41, 41, 25, 25, 25, 25, 9, 9,
    9, 71, 71, 71, 55, 55, 55, 39, 39, 39, 39, 23, 23, 23, 7, 7,
    7, 69, 69, 69, 53, 53, 53, 37, 37, 37, 37, 21, 21, 21, 5, 5,
    5, 67, 67, 67, 51, 51, 51, 51, 35, 35, 35, 19, 19, 19, 3, 3,
    3, 65, 65, 65, 49, 49, 49, 49, 33, 33, 33, 17, 17, 17, 1, 1,
    // QUANT_96
    0, 0, 32, 32, 64, 64, 64, 2, 2, 2, 34, 34, 66, 66, 66, 4,
    4, 4, 36, 36, 68, 68, 68, 6, 6, 6, 38, 38, 70, 70, 70, 8,
    8, 8, 40, 40, 40, 72, 72, 10, 10, 10, 42, 42, 42, 74, 74, 12,
    12, 12, 44, 44, 44, 76, 76, 14, 14, 14, 46, 46, 46, 78, 78, 16,
    16, 16, 48, 48, 48, 80, 80, 80, 18, 18, 50, 50, 50, 82, 82, 82,
    20, 20, 52, 52, 52, 84, 84, 84, 22, 22, 54, 54, 54, 86, 86, 86,
    24, 24, 56, 56, 56, 88, 88, 88, 26, 26, 58, 58, 58, 90, 90, 90,
    28, 28, 60, 60, 60, 92, 92, 92, 30, 30, 62, 62, 62, 94, 94, 94,
    95, 95, 95, 63, 63, 63, 31, 31, 93, 93, 93, 61, 61, 61, 29, 29,
    91, 91, 91, 59, 59, 59, 27, 27, 89, 89, 89, 57, 57, 57, 25, 25,
    87, 87, 87, 55, 55, 55, 23, 23, 85, 85, 85, 53, 53, 53, 21, 21,
    83, 83, 83, 51, 51, 51, 19, 19, 81, 81, 81, 49, 49, 49, 17, 17,
    17, 79, 79, 47, 47, 47, 15, 15, 15, 77, 77, 45, 45, 45, 13, 13,
    13, 75, 75, 43, 43, 43, 11, 11, 11, 73, 73, 41, 41, 41, 9, 9,
    9, 71, 71, 71, 39, 39, 7, 7, 7, 69, 69, 69, 37, 37, 5, 5,
    5, 67, 67, 67, 35, 35, 3, 3, 3, 65, 65, 65, 33, 33, 1, 1,
    // QUANT_128
    0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7,
    8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15,
    16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
    24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31,
    32, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37, 38, 38, 39, 39,
    40, 40, 41, 41, 42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47, 47,
    48, 48, 49, 49, 50, 50, 51, 51, 52, 52, 53, 53, 54, 54, 55, 55,
    56, 56, 57, 57, 58, 58, 59, 59, 60, 60, 61, 61, 62, 62, 63, 63,
    64, 64, 65, 65, 66, 66, 67, 67, 68, 68, 69, 69, 70, 70, 71, 71,
    72, 72, 73, 73, 74, 74, 75, 75, 76, 76, 77, 77, 78, 78, 79, 79,
    80, 80, 81, 81, 82, 82, 83, 83, 84, 84, 85, 85, 86, 86, 87, 87,
    88, 88, 89, 89, 90, 90, 91, 91, 92, 92, 93, 93, 94, 94, 95, 95,
    96, 96, 97, 97, 98, 98, 99, 99, 100, 100, 101, 101, 102, 102, 103, 103,
    104, 104, 105, 105, 106, 106, 107, 107, 108, 108, 109, 109, 110, 110, 111, 111,
    112, 112, 113, 113, 114, 114, 115, 115, 116, 116, 117, 117, 118, 118, 119, 119,
    120, 120, 121, 121, 122, 122, 123, 123, 124, 124, 125, 125, 126, 126, 127, 127,
    // QUANT_160
    0, 32, 32, 64, 96, 96, 128, 128, 2, 34, 34, 66, 98, 98, 130, 130,
    4, 36, 36, 68, 100, 100, 132, 132, 6, 38, 38, 70, 102, 102, 134, 134,
    8, 40, 40, 72, 104, 104, 136, 136, 10, 42, 42, 74, 106, 106, 138, 138,
    12, 44, 44, 76, 108, 108, 140, 140, 14, 46, 46, 78, 110, 110, 142, 142,
    16, 48, 48, 80, 112, 112, 144, 144, 18, 50, 50, 82, 114, 114, 146, 146,
    20, 52, 52, 84, 116, 116, 148, 148, 22, 54, 54, 86, 118, 118, 150, 150,
    24, 56, 56, 88, 120, 120, 152, 152, 26, 58, 58, 90, 122, 122, 154, 154,
    28, 60, 60, 92, 124, 124, 156, 156, 30, 62, 62, 94, 126, 126, 158, 158,
    159, 159, 127, 127, 95, 63, 63, 31, 157, 157, 125, 125, 93, 61, 61, 29,
    155, 155, 123, 123, 91, 59, 59, 27, 153, 153, 121, 121, 89, 57, 57, 25,
    151, 151, 119, 119, 87, 55, 55, 23, 149, 149, 117, 117, 85, 53, 53, 21,
    147, 147, 115, 115, 83, 51, 51, 19, 145, 145, 113, 113, 81, 49, 49, 17,
    143, 143, 111, 111, 79, 47, 47, 15, 141, 141, 109, 109, 77, 45, 45, 13,
    139, 139, 107, 107, 75, 43, 43, 11, 137, 137, 105, 105, 73, 41, 41, 9,
    135, 135, 103, 103, 71, 39, 39, 7, 133, 133, 101, 101, 69, 37, 37, 5,
    131, 131, 99, 99, 67, 35, 35, 3, 129, 129, 97, 97, 65, 33, 33, 1,
    // QUANT_192
    0, 64, 128, 128, 2, 66, 130, 130, 4, 68, 132, 132, 6, 70, 134, 134,
    8, 72, 136, 136, 10, 74, 138, 138, 12, 76, 140, 140, 14, 78, 142, 142,
    16, 80, 144, 144, 18, 82, 146, 146, 20, 84, 148, 148, 22, 86, 150, 150,
    24, 88, 152, 152, 26, 90, 154, 154, 28, 92, 156, 156, 30, 94, 158, 158,
    32, 96, 160, 160, 34, 98, 162, 162, 36, 100, 164, 164, 38, 102, 166, 166,
    40, 104, 168, 168, 42, 106, 170, 170, 44, 108, 172, 172, 46, 110, 174, 174,
    48, 112, 176, 176, 50, 114, 178, 178, 52, 116, 180, 180, 54, 118, 182, 182,
    56, 120, 184, 184, 58, 122, 186, 186, 60, 124, 188, 188, 62, 126, 190, 190,
    191, 191, 127, 63, 189, 189, 125, 61, 187, 187, 123, 59, 185, 185, 121, 57,
    183, 183, 119, 55, 181, 181, 117, 53, 179, 179, 115, 51, 177, 177, 113, 49,
    175, 175, 111, 47, 173, 173, 109, 45, 171, 171, 107, 43, 169, 169, 105, 41,
    167, 167, 103, 39, 165, 165, 101, 37, 163, 163, 99, 35, 161, 161, 97, 33,
    159, 159, 95, 31, 157, 157, 93, 29, 155, 155, 91, 27, 153, 153, 89, 25,
    151, 151, 87, 23, 149, 149, 85, 21, 147, 147, 83, 19, 145, 145, 81, 17,
    143, 143, 79, 15, 141, 141, 77, 13, 139, 139, 75, 11, 137, 137, 73, 9,
    135, 135, 71, 7, 133, 133, 69, 5, 131, 131, 67, 3, 129, 129, 65, 1,
    // QUANT_256
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
    96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
    112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
    208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
};

__constant short color_unquant_tables[21][256] = {
    {
        0, 255
    },
    {
        0, 128, 255
    },
    {
        0, 85, 170, 255
    },
    {
        0, 64, 128, 192, 255
    },
    {
        0, 255, 51, 204, 102, 153
    },
    {
        0, 36, 73, 109, 146, 182, 219, 255
    },
    {
        0, 255, 28, 227, 56, 199, 84, 171, 113, 142
    },
    {
        0, 255, 69, 186, 23, 232, 92, 163, 46, 209, 116, 139
    },
    { // 16
        0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255
    },
    { // 20
        0, 255, 67, 188, 13, 242, 80, 175, 27, 228, 94, 161, 40, 215, 107, 148,
        54, 201, 121, 134
    },
    { // 24
        0, 255, 33, 222, 66, 189, 99, 156, 11, 244, 44, 211, 77, 178, 110, 145,
        22, 233, 55, 200, 88, 167, 121, 134
    },
    { // 32
        0, 8, 16, 24, 33, 41, 49, 57, 66, 74, 82, 90, 99, 107, 115, 123,
        132, 140, 148, 156, 165, 173, 181, 189, 198, 206, 214, 222, 231, 239, 247, 255
    },
    { // 40
        0, 255, 32, 223, 65, 190, 97, 158, 6, 249, 39, 216, 71, 184, 104, 151,
        13, 242, 45, 210, 78, 177, 110, 145, 19, 236, 52, 203, 84, 171, 117, 138,
        26, 229, 58, 197, 91, 164, 123, 132
    },
    { // 48
        0, 255, 16, 239, 32, 223, 48, 207, 65, 190, 81, 174, 97, 158, 113, 142,
        5, 250, 21, 234, 38, 217, 54, 201, 70, 185, 86, 169, 103, 152, 119, 136,
        11, 244, 27, 228, 43, 212, 59, 196, 76, 179, 92, 163, 108, 147, 124, 131
    },
    { // 64
        0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60,
        65, 69, 73, 77, 81, 85, 89, 93, 97, 101, 105, 109, 113, 117, 121, 125,
        130, 134, 138, 142, 146, 150, 154, 158, 162, 166, 170, 174, 178, 182, 186, 190,
        195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255
    },
    { // 80
        0, 255, 16, 239, 32, 223, 48, 207, 64, 191, 80, 175, 96, 159, 112, 143,
        3, 252, 19, 236, 35, 220, 51, 204, 67, 188, 83, 172, 100, 155, 116, 139,
        6, 249, 22, 233, 38, 217, 54, 201, 71, 184, 87, 168, 103, 152, 119, 136,
        9, 246, 25, 230, 42, 213, 58, 197, 74, 181, 90, 165, 106, 149, 122, 133,
        13, 242, 29, 226, 45, 210, 61, 194, 77, 178, 93, 162, 109, 146, 125, 130
    },
    { // 96
        0, 255, 8, 247, 16, 239, 24, 231, 32, 223, 40, 215, 48, 207, 56, 199,
        64, 191, 72, 183, 80, 175, 88, 167, 96, 159, 104, 151, 112, 143, 120, 135,
        2, 253, 10, 245, 18, 237, 26, 229, 35, 220, 43, 212, 51, 204, 59, 196,
        67, 188, 75, 180, 83, 172, 91, 164, 99, 156, 107, 148, 115, 140, 123, 132,
        5, 250, 13, 242, 21, 234, 29, 226, 37, 218, 45, 210, 53, 202, 61, 194,
        70, 185, 78, 177, 86, 169, 94, 161, 102, 153, 110, 145, 118, 137, 126, 129
    },
    { // 128
        0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,
        32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
        64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
        96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
        129, 131, 133, 135, 137, 139, 141, 143, 145, 147, 149, 151, 153, 155, 157, 159,
        161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 189, 191,
        193, 195, 197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223,
        225, 227, 229, 231, 233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 253, 255
    },
    { // 160
        0, 255, 8, 247, 16, 239, 24, 231, 32, 223, 40, 215, 48, 207, 56, 199,
        64, 191, 72, 183, 80, 175, 88, 167, 96, 159, 104, 151, 112, 143, 120, 135,
        1, 254, 9, 246, 17, 238, 25, 230, 33, 222, 41, 214, 49, 206, 57, 198,
        65, 190, 73, 182, 81, 174, 89, 166, 97, 158, 105, 150, 113, 142, 121, 134,
        3, 252, 11, 244, 19, 236, 27, 228, 35, 220, 43, 212, 51, 204, 59, 196,
        67, 188, 75, 180, 83, 172, 91, 164, 99, 156, 107, 148, 115, 140, 123, 132,
        4, 251, 12, 243, 20, 235, 28, 227, 36, 219, 44, 211, 52, 203, 60, 195,
        68, 187, 76, 179, 84, 171, 92, 163, 100, 155, 108, 147, 116, 139, 124, 131,
        6, 249, 14, 241, 22, 233, 30, 225, 38, 217, 46, 209, 54, 201, 62, 193,
        70, 185, 78, 177, 86, 169, 94, 161, 102, 153, 110, 145, 118, 137, 126, 129
    },
    {
        0, 255, 4, 251, 8, 247, 12, 243, 16, 239, 20, 235, 24, 231, 28, 227,
        32, 223, 36, 219, 40, 215, 44, 211, 48, 207, 52, 203, 56, 199, 60, 195,
        64, 191, 68, 187, 72, 183, 76, 179, 80, 175, 84, 171, 88, 167, 92, 163,
        96, 159, 100, 155, 104, 151, 108, 147, 112, 143, 116, 139, 120, 135, 124, 131,
        1, 254, 5, 250, 9, 246, 13, 242, 17, 238, 21, 234, 25, 230, 29, 226,
        33, 222, 37, 218, 41, 214, 45, 210, 49, 206, 53, 202, 57, 198, 61, 194,
        65, 190, 69, 186, 73, 182, 77, 178, 81, 174, 85, 170, 89, 166, 93, 162,
        97, 158, 101, 154, 105, 150, 109, 146, 113, 142, 117, 138, 121, 134, 125, 130,
        2, 253, 6, 249, 10, 245, 14, 241, 18, 237, 22, 233, 26, 229, 30, 225,
        34, 221, 38, 217, 42, 213, 46, 209, 50, 205, 54, 201, 58, 197, 62, 193,
        66, 189, 70, 185, 74, 181, 78, 177, 82, 173, 86, 169, 90, 165, 94, 161,
        98, 157, 102, 153, 106, 149, 110, 145, 114, 141, 118, 137, 122, 133, 126, 129
    },
    {
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127,
        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
    }
};

void swap(float4* lhs, float4* rhs)
{
    float4 tmp = *lhs;
    *lhs = *rhs;
    *rhs = tmp;
}

void find_min_max(float4* texels, float4 pt_mean, float4 vec_k, float4* e0, float4* e1, bool has_alpha)
{
    float a = 1e31f;
    float b = -1e31f;
    for (int i = 0; i < BLOCK_SIZE; ++i) {
        float t = dot(texels[i] - pt_mean, vec_k);
        a = min(a, t);
        b = max(b, t);
    }

    *e0 = clamp(vec_k * a + pt_mean, 0.0f, 255.0f);
    *e1 = clamp(vec_k * b + pt_mean, 0.0f, 255.0f);

    // if the direction_vector ends up pointing from light to dark, FLIP IT!
    // this will make the endpoint the darkest one;
    float4 e0u = round(*e0);
    float4 e1u = round(*e1);
    if (e0u.x + e0u.y + e0u.z > e1u.x + e1u.y + e1u.z) {
        swap(e0, e1);
    }

    if (!has_alpha) {
        (*e0).w = 255.0f;
        (*e1).w = 255.0f;
    }
}

void max_accumulation_pixel_direction(float4* texels, float4 pt_mean, float4* e0, float4* e1, bool has_alpha)
{
    int i = 0;

    float4 sum_r = (float4)(0);
    float4 sum_g = (float4)(0);
    float4 sum_b = (float4)(0);
    float4 sum_a = (float4)(0);
    for (i = 0; i < BLOCK_SIZE; ++i) {
        float4 dt = texels[i] - pt_mean;
        sum_r += (dt.x > 0.0f) ? dt : (float4)(0);
        sum_g += (dt.y > 0.0f) ? dt : (float4)(0);
        sum_b += (dt.z > 0.0f) ? dt : (float4)(0);
        sum_a += (dt.w > 0.0f) ? dt : (float4)(0);
    }

    float dot_r = dot(sum_r, sum_r);
    float dot_g = dot(sum_g, sum_g);
    float dot_b = dot(sum_b, sum_b);
    float dot_a = dot(sum_a, sum_a);

    float maxdot = dot_r;
    float4 vec_k = sum_r;

    if (dot_g > maxdot) {
        vec_k = sum_g;
        maxdot = dot_g;
    }

    if (dot_b > maxdot) {
        vec_k = sum_b;
        maxdot = dot_b;
    }

    if (has_alpha && dot_a > maxdot) {
        vec_k = sum_a;
        maxdot = dot_a;
    }

    // safe normalize
    float lenk = length(vec_k);
    vec_k = (lenk < SMALL_VALUE) ? vec_k : normalize(vec_k);

    find_min_max(texels, pt_mean, vec_k, e0, e1, has_alpha);
}

void encode_color_normal(short quant_level, float4 e0, float4 e1, short* endpoint_quantized)
{
    int4 e0q = (int4)((int)(round(e0.x)), (int)(round(e0.y)), (int)(round(e0.z)), (int)(round(e0.w)));
    int4 e1q = (int4)((int)(round(e1.x)), (int)(round(e1.y)), (int)(round(e1.z)), (int)(round(e1.w)));

    endpoint_quantized[0] = color_quant_tables[quant_level * 256 + e0q.x];
    endpoint_quantized[1] = color_quant_tables[quant_level * 256 + e1q.x];
    endpoint_quantized[2] = color_quant_tables[quant_level * 256 + e0q.y];
    endpoint_quantized[3] = color_quant_tables[quant_level * 256 + e1q.y];
    endpoint_quantized[4] = color_quant_tables[quant_level * 256 + e0q.z];
    endpoint_quantized[5] = color_quant_tables[quant_level * 256 + e1q.z];
    endpoint_quantized[6] = color_quant_tables[quant_level * 256 + e0q.w];
    endpoint_quantized[7] = color_quant_tables[quant_level * 256 + e1q.w];
}

void decode_color(short quant_level, short endpoint_quantized[8], float4* e0, float4* e1)
{
    (*e0).x = (float)(color_unquant_tables[quant_level][endpoint_quantized[0]]);
    (*e1).x = (float)(color_unquant_tables[quant_level][endpoint_quantized[1]]);
    (*e0).y = (float)(color_unquant_tables[quant_level][endpoint_quantized[2]]);
    (*e1).y = (float)(color_unquant_tables[quant_level][endpoint_quantized[3]]);
    (*e0).z = (float)(color_unquant_tables[quant_level][endpoint_quantized[4]]);
    (*e1).z = (float)(color_unquant_tables[quant_level][endpoint_quantized[5]]);
    (*e0).w = (float)(color_unquant_tables[quant_level][endpoint_quantized[6]]);
    (*e1).w = (float)(color_unquant_tables[quant_level][endpoint_quantized[7]]);
}

//calculate quantize weights
short quantize_weight(uint weight_range, float weight)
{
    short q = (short)(round(weight * (float)(weight_range)));
    return clamp(q, (short)(0), (short)(weight_range));
}

float unquantize_weight(uint weight_range, uint qw)
{
    float w = 1.0f * (float)(qw) / (float)(weight_range);
    return clamp(w, 0.0f, 1.0f);
}

float4 samp_texel(float4 texels[BLOCK_SIZE], uint4 index, float4 coff)
{
    float4 sum = texels[index.x] * coff.x;
    sum += texels[index.y] * coff.y;
    sum += texels[index.z] * coff.z;
    sum += texels[index.w] * coff.w;
    return sum;
}

void calculate_normal_weights_2plane(float4* texels,
    float4 ep0, float4 ep1, int component_plane2, float* projw)
{
    int i = 0;
    float4 vec_k = ep1 - ep0;
    if (length(vec_k) < SMALL_VALUE) {
        for (i = 0; i < 2 * X_GRIDS * Y_GRIDS; ++i) {
            projw[i] = 0.0f;
        }
    } else {
        float minw = 1e31f;
        float maxw = -1e31f;
        float minwp = 1e31f;
        float maxwp = -1e31f;
        if (component_plane2 == 0) {
            vec_k = normalize((float4)(0, vec_k.y, vec_k.z, vec_k.w));
        } else if (component_plane2 == 1) {
            vec_k = normalize((float4)(vec_k.x, 0, vec_k.z, vec_k.w));
        } else if (component_plane2 == 2) {
            vec_k = normalize((float4)(vec_k.x, vec_k.y, 0, vec_k.w));
        } else if (component_plane2 == 3) {
            vec_k = normalize((float4)(vec_k.x, vec_k.y, vec_k.z, 0));
        }
        for (i = 0; i < BLOCK_SIZE; ++i) {
            float4 texel = texels[i];
            float w = dot(vec_k, texel - ep0);
            minw = min(w, minw);
            maxw = max(w, maxw);
            projw[2*i] = w;

            float wp = texel.x - ep0.x;
            if (component_plane2 == 1) {
                wp = texel.y - ep0.y;
            } else if (component_plane2 == 2) {
                wp = texel.z - ep0.z;
            } else if (component_plane2 == 3) {
                wp = texel.w - ep0.w;
            }
            minwp = min(wp, minwp);
            maxwp = max(wp, maxwp);
            projw[2 * i + 1] = wp;
        }
        float invlen = maxw - minw;
        float invlenp = maxwp - minwp;
        invlen = max(SMALL_VALUE, invlen);
        invlen = 1.0f / invlen;
        invlenp = max(SMALL_VALUE, invlenp);
        invlenp = 1.0f / invlenp;
        for (i = 0; i < X_GRIDS * Y_GRIDS; ++i) {
            projw[2 * i] = (projw[2 * i] - minw) * invlen;
            projw[2 * i + 1] = (projw[2 * i + 1] - minwp) * invlenp;
        }
    }
}

void calculate_normal_weights(int part, PartInfo* part_info, float4* texels, float4 ep0, float4 ep1, float* projw)
{
    int i = 0;
    float4 vec_k = ep1 - ep0;
    if (length(vec_k) < SMALL_VALUE && !part_info) {
        for (i = 0; i < X_GRIDS * Y_GRIDS; ++i) {
            projw[i] = 0.0f;
        }
    } else {
        vec_k = normalize(vec_k);
        float minw = 1e31f;
        float maxw = -1e31f;
        for (i = 0; i < BLOCK_SIZE; ++i) {
            if (!part_info) {
                float w = dot(vec_k, texels[i] - ep0);
                minw = min(w, minw);
                maxw = max(w, maxw);
                projw[i] = w;
            } else {
                int cur_part = get_part(part_info, i);
                if (cur_part == part) {
                    float w = dot(vec_k, texels[i] - ep0);
                    minw = min(w, minw);
                    maxw = max(w, maxw);
                    projw[i] = w;
                }
            }
        }
        float invlen = maxw - minw;
        invlen = max(SMALL_VALUE, invlen);
        invlen = 1.0f / invlen;
        for (i = 0; i < X_GRIDS * Y_GRIDS; ++i) {
            if (!part_info) {
                projw[i] = (projw[i] - minw) * invlen;
            } else {
                int cur_part = get_part(part_info, i);
                if (cur_part  == part) {
                    projw[i] = (projw[i] - minw) * invlen;
                }
            }
        }
    }
}

void quantize_weights_rgb(float projw[2 * X_GRIDS * Y_GRIDS], uint weight_range, short* weights)
{
    for (int i = 0; i < 2 * X_GRIDS * Y_GRIDS; ++i) {
        weights[i] = quantize_weight(weight_range, projw[i]);
    }
}

void calculate_quantized_weights_2plane(float4* texels,
uint weight_range,
float4 ep0,
float4 ep1,
short* weights,
int component_plane2)
{
    float projw[2 * X_GRIDS * Y_GRIDS];
    calculate_normal_weights_2plane(texels, ep0, ep1, component_plane2, projw);
    quantize_weights_rgb(projw, weight_range, weights);
    return;
}

void quantize_weights(float projw[X_GRIDS * Y_GRIDS], uint weight_range, short* weights)
{
    for (int i = 0; i < X_GRIDS * Y_GRIDS; ++i) {
        weights[i] = quantize_weight(weight_range, projw[i]);
    }
}

void calculate_quantized_weights(float4* texels, uint weight_range, float4 ep0, float4 ep1, short* weights)
{
    float projw[X_GRIDS * Y_GRIDS];
    calculate_normal_weights(0, NULL, texels, ep0, ep1, projw);
    quantize_weights(projw, weight_range, weights);
}

void orbits8_ptr(uint4* outputs, uint* bitoffset, uint number, uint bitcount)
{
    uint newpos = *bitoffset + bitcount;

    uint nidx = newpos >> 5;
    uint uidx = *bitoffset >> 5;
    uint bit_idx = *bitoffset & 31u;
    if (uidx == 0) {
        (*outputs).x |= (number << bit_idx);
        (*outputs).y |= (nidx >uidx) ? (number >> (32u - bit_idx)) : 0u;
    } else if (uidx == 1) {
        (*outputs).y |= (number << bit_idx);
        (*outputs).z |= (nidx >uidx) ? (number >> (32u - bit_idx)) : 0u;
    } else if (uidx == 2) {
        (*outputs).z |= (number << bit_idx);
        (*outputs).w |= (nidx >uidx) ? (number >> (32u - bit_idx)) : 0u;
    } else if (uidx == 3) {
    }
    *bitoffset = newpos;
}

void split_high_low(uint n, uint i, int* high, uint* low)
{
    uint low_mask = (1u << i) - 1u;
    *low = n & low_mask;
    *high = (int)(n >> i) & 0xFF;
}

uint reverse_byte(uint p)
{
    p = ((p & 0xFu) << 4) | ((p >> 4) & 0xFu);
    p = ((p & 0x33u) << 2) | ((p >> 2) & 0x33u);
    p = ((p & 0x55u) << 1) | ((p >> 1) & 0x55u);
    return p;
}

void encode_trits(uint bitcount,
uint b0, uint b1, uint b2, uint b3, uint b4,
uint4* outputs, uint* outpos)
{
    int t0, t1, t2, t3, t4;
    uint m0, m1, m2, m3, m4;
    split_high_low(b0, bitcount, &t0, &m0);
    split_high_low(b1, bitcount, &t1, &m1);
    split_high_low(b2, bitcount, &t2, &m2);
    split_high_low(b3, bitcount, &t3, &m3);
    split_high_low(b4, bitcount, &t4, &m4);

    ushort packhigh = (ushort)(integer_from_trits[t4 * 81 + t3 * 27 + t2 * 9 + t1 * 3 + t0]);

    orbits8_ptr(outputs, outpos, m0, bitcount);
    orbits8_ptr(outputs, outpos, packhigh & 3u, 2u);

    orbits8_ptr(outputs, outpos, m1, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 2) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m2, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 4) & 1u, 1u);

    orbits8_ptr(outputs, outpos, m3, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 5) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m4, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 7) & 1u, 1u);
}

void encode_quints(uint bitcount, uint b0, uint b1, uint b2, uint4* outputs, uint* outpos)
{
    int q0, q1, q2;
    uint m0, m1, m2;

    split_high_low(b0, bitcount, &q0, &m0);
    split_high_low(b1, bitcount, &q1, &m1);
    split_high_low(b2, bitcount, &q2, &m2);

    ushort packhigh = (ushort)(integer_from_quints[q2 * 25 + q1 * 5 + q0]);

    orbits8_ptr(outputs, outpos, m0, bitcount);
    orbits8_ptr(outputs, outpos, packhigh & 7u, 3u);

    orbits8_ptr(outputs, outpos, m1, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 3) & 3u, 2u);

    orbits8_ptr(outputs, outpos, m2, bitcount);
    orbits8_ptr(outputs, outpos, (packhigh >> 5) & 3u, 2u);
}

void bise_endpoints(short numbers[8], int range, uint4* outputs, bool has_alpha, uint* bitpos)
{
    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    uint count = has_alpha ? 8u : 6u;

    if (trits == 1u) {
        encode_trits(bits, numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], outputs, bitpos);
        encode_trits(bits, numbers[5], numbers[6], numbers[7], 0u, 0u, outputs, bitpos);
        *bitpos = ((8u + 5u * bits) * count + 4u) / 5u;
    } else if (quints == 1u) {
        encode_quints(bits, numbers[0], numbers[1], numbers[2], outputs, bitpos);
        encode_quints(bits, numbers[3], numbers[4], numbers[5], outputs, bitpos);
        encode_quints(bits, numbers[6], numbers[7], 0u, outputs, bitpos);
        *bitpos = ((7u + 3u * bits) * count + 2u) / 3u;
    } else {
        for (uint i = 0u; i < count; ++i) {
            orbits8_ptr(outputs, bitpos, numbers[i], bits);
        }
    }
}

void bise_weights(short numbers[16], int range, uint4* outputs)
{
    uint bitpos = 0u;
    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    if (trits == 1u) {
        encode_trits(bits, numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], outputs, &bitpos);
        encode_trits(bits, numbers[5], numbers[6], numbers[7], numbers[8], numbers[9], outputs, &bitpos);
        encode_trits(bits, numbers[10], numbers[11], numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_trits(bits, numbers[15], 0u, 0u, 0u, 0u, outputs, &bitpos);
        bitpos = ((8u + 5u * bits) * 16u + 4u) / 5u;
    } else if (quints == 1u) {
        encode_quints(bits, numbers[0], numbers[1], numbers[2], outputs, &bitpos);
        encode_quints(bits, numbers[3], numbers[4], numbers[5], outputs, &bitpos);
        encode_quints(bits, numbers[6], numbers[7], numbers[8], outputs, &bitpos);
        encode_quints(bits, numbers[9], numbers[10], numbers[11], outputs, &bitpos);
        encode_quints(bits, numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_quints(bits, numbers[15], 0u, 0u, outputs, &bitpos);
        bitpos = ((7u + 3u * bits) * 16u + 2u) / 3u;
    } else {
        for (int i = 0; i < 16; ++i) {
            orbits8_ptr(outputs, &bitpos, numbers[i], bits);
        }
    }
}

uint bise_weights_2plane(short numbers[32], int range, uint4* outputs)
{
    uint bitpos = 0u;

    uint bits = (uint)(bits_trits_quints_table[range * 3 + 0]);
    uint trits = (uint)(bits_trits_quints_table[range * 3 + 1]);
    uint quints = (uint)(bits_trits_quints_table[range * 3 + 2]);

    if (trits == 1u) {
        encode_trits(bits, numbers[0], numbers[1], numbers[2], numbers[3], numbers[4], outputs, &bitpos);
        encode_trits(bits, numbers[5], numbers[6], numbers[7], numbers[8], numbers[9], outputs, &bitpos);
        encode_trits(bits, numbers[10], numbers[11], numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_trits(bits, numbers[15], numbers[16], numbers[17], numbers[18], numbers[19], outputs, &bitpos);
        encode_trits(bits, numbers[20], numbers[21], numbers[22], numbers[23], numbers[24], outputs, &bitpos);
        encode_trits(bits, numbers[25], numbers[26], numbers[27], numbers[28], numbers[29], outputs, &bitpos);
        encode_trits(bits, numbers[30], numbers[31], 0u, 0u, 0u, outputs, &bitpos);
        bitpos = ((8u + 5u * bits) * 32u + 4u) / 5u;
    } else if (quints == 1u) {
        encode_quints(bits, numbers[0], numbers[1], numbers[2], outputs, &bitpos);
        encode_quints(bits, numbers[3], numbers[4], numbers[5], outputs, &bitpos);
        encode_quints(bits, numbers[6], numbers[7], numbers[8], outputs, &bitpos);
        encode_quints(bits, numbers[9], numbers[10], numbers[11], outputs, &bitpos);
        encode_quints(bits, numbers[12], numbers[13], numbers[14], outputs, &bitpos);
        encode_quints(bits, numbers[15], numbers[16], numbers[17], outputs, &bitpos);
        encode_quints(bits, numbers[18], numbers[19], numbers[20], outputs, &bitpos);
        encode_quints(bits, numbers[21], numbers[22], numbers[23], outputs, &bitpos);
        encode_quints(bits, numbers[24], numbers[25], numbers[26], outputs, &bitpos);
        encode_quints(bits, numbers[27], numbers[28], numbers[29], outputs, &bitpos);
        encode_quints(bits, numbers[30], numbers[31], 0u, outputs, &bitpos);
        bitpos = ((7u + 3u * bits) * 32u + 2u) / 3u;
    } else {
        for (int i = 0; i < 32; ++i) {
            orbits8_ptr(outputs, &bitpos, numbers[i], bits);
        }
    }
    return bitpos;
}

uint4 assemble_block(uint blockmode, uint color_endpoint_mode,
                     uint partition_count, uint partition_index, uint4 ep_ise, uint4 wt_ise)
{
    uint4 phy_blk = (uint4)(0, 0, 0, 0);
    phy_blk.w |= reverse_byte(wt_ise.x & 0xFFu) << 24;
    phy_blk.w |= reverse_byte((wt_ise.x >> 8) & 0xFFu) << 16;
    phy_blk.w |= reverse_byte((wt_ise.x >> 16) & 0xFFu) << 8;
    phy_blk.w |= reverse_byte((wt_ise.x >> 24) & 0xFFu);

    phy_blk.z |= reverse_byte(wt_ise.y & 0xFFu) << 24;
    phy_blk.z |= reverse_byte((wt_ise.y >> 8) & 0xFFu) << 16;
    phy_blk.z |= reverse_byte((wt_ise.y >> 16) & 0xFFu) << 8;
    phy_blk.z |= reverse_byte((wt_ise.y >> 24) & 0xFFu);

    phy_blk.y |= reverse_byte(wt_ise.z & 0xFFu) << 24;
    phy_blk.y |= reverse_byte((wt_ise.z >> 8) & 0xFFu) << 16;
    phy_blk.y |= reverse_byte((wt_ise.z >> 16) & 0xFFu) << 8;
    phy_blk.y |= reverse_byte((wt_ise.z >> 24) & 0xFFu);

    phy_blk.x = blockmode;

    if (partition_count > 1u) {
        uint endpoint_offset = 29u;
        uint cem_bits = 6u;
        uint bitpos = 11u;
        orbits8_ptr(&phy_blk, &bitpos, partition_count - 1u, 2u);
        orbits8_ptr(&phy_blk, &bitpos, partition_index & 63u, 6u);
        orbits8_ptr(&phy_blk, &bitpos, partition_index >> 6, 4u);
        orbits8_ptr(&phy_blk, &bitpos, color_endpoint_mode << 2, 6u);

        phy_blk.x |= (ep_ise.x & 0x7u) << 29;
        phy_blk.y |= ((ep_ise.x >> 3) & 0x1FFFFFFFu);
        phy_blk.y |= (ep_ise.y & 0x7u) <<29;
        phy_blk.z |= ((ep_ise.y >> 3) & 0x1FFFFFFFu);
    } else {
        phy_blk.x |= (color_endpoint_mode & 0xFu) << 13;
        phy_blk.x |= (ep_ise.x & 0x7FFFu) << 17;
        phy_blk.y |= ((ep_ise.x >> 15) & 0x1FFFFu);
        phy_blk.y |= (ep_ise.y & 0x7FFFu) << 17;
        phy_blk.z |= ((ep_ise.y >> 15) & 0x1FFFFu);
    }

    return phy_blk;
}

uint assemble_blockmode(uint weight_quantmethod, bool is_dual_plane)
{
    uint a = (uint)((Y_GRIDS - 2) & 0x3);
    uint b = (uint)((X_GRIDS - 4) & 0x3);

    uint d = is_dual_plane ? 1u : 0u;

    uint h = (weight_quantmethod < 6u) ? 0u : 1u;
    uint r = (weight_quantmethod % 6u) + 2u;

    uint blockmode = (r >> 1) & (uint)(0x3);
    blockmode |= (r & (uint)(0x1)) << 4u;
    blockmode |= (a & (uint)(0x3)) << 5u;
    blockmode |= (b & (uint)(0x3)) << 7u;
    blockmode |= h << 9u;
    blockmode |= d << 10u;
    return blockmode;
}

uint4 endpoint_ise(float4* ep0, float4* ep1, short endpoint_quantmethod, bool has_alpha)
{
    short ep_quantized[8];
    encode_color_normal(endpoint_quantmethod, *ep0, *ep1, ep_quantized);
    decode_color(endpoint_quantmethod, ep_quantized, ep0, ep1);

    if (!has_alpha) {
        ep_quantized[6] = 0;
        ep_quantized[7] = 0;
    }

    uint4 ep_ise = (uint4)(0);
    uint bitpos = 0u;
    bise_endpoints(ep_quantized, endpoint_quantmethod, &ep_ise, has_alpha, &bitpos);
    return ep_ise;
}

float4 cal_texel(short weight, float4 ep0, float4 ep1) {
    short weight0 = 64 - weight;
    return (ep0 * weight0 + ep1 * weight) / 64.0f;
}

uint4 weight_ise_2plane(float4* texels, uint weight_range, float4 ep0,
    float4 ep1, short weight_quantmethod, int component_plane2, float* errval)
{
    int i = 0;
    short wt_quantized[2 * X_GRIDS * Y_GRIDS];
    calculate_quantized_weights_2plane(texels, weight_range, ep0, ep1, wt_quantized, component_plane2);

    float sum_err = 0.0f;
    for (i = 0; i < 2 * X_GRIDS * Y_GRIDS; ++i) {
        short w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
        wt_quantized[i] = scramble_table[w];
        bool odd = (i % 2 == 1);
        if (odd) {
            short w_even = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i - 1];
            w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
            short wt = weight_unquant[w_even];
            short wt1 = weight_unquant[w];
            float4 new_texel = cal_texel(wt, ep0, ep1);
            float4 tex = cal_texel(wt1, ep0, ep1);
            if (component_plane2 == 0) {
                new_texel.x = tex.x;
            } else if (component_plane2 == 1) {
                new_texel.y = tex.y;
            } else if (component_plane2 == 2) {
                new_texel.z = tex.z;
            } else if (component_plane2 == 3) {
                new_texel.w = tex.w;
            }
            float4 curTexel = texels[i >> 2];
            float4 diff = new_texel - curTexel;
            sum_err += dot(diff, diff);
        }
    }
    *errval = sum_err;

    uint4 wt_ise = (uint4)(0);
    uint bitpos = bise_weights_2plane(wt_quantized, (int)(weight_quantmethod), &wt_ise);
    component_plane2 = ((component_plane2 >> 1) & 0x3) | ((component_plane2 << 1) & 0x3);
    orbits8_ptr(&wt_ise, &bitpos, (uint)(component_plane2), 2u);
    return wt_ise;
}

uint4 weight_ise(float4* texels, uint weight_range, float4 ep0, float4 ep1, short weight_quantmethod, float* errval)
{
    int i = 0;
    short wt_quantized[X_GRIDS * Y_GRIDS];
    calculate_quantized_weights(texels, weight_range, ep0, ep1, wt_quantized);

    float sum_err = 0.0f;
    for (i = 0; i < X_GRIDS * Y_GRIDS; ++i) {
        short w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
        wt_quantized[i] = scramble_table[w];
        w = weight_quantmethod * WEIGHT_QUANTIZE_NUM + wt_quantized[i];
        short wt = weight_unquant[w];
        float4 new_texel = cal_texel(wt, ep0, ep1);
        float4 diff = new_texel - texels[i];
        sum_err += dot(diff, diff);
    }
    *errval = sum_err;
    uint4 wt_ise = (uint4)(0);
    bise_weights(wt_quantized, (int)(weight_quantmethod), &wt_ise);
    return wt_ise;
}
uint hash52(uint inp) {
    inp ^= inp >> 15;

    inp *= 0xEEDE0891u;
    inp ^= (inp >> 5) & 0x7FFFFFFu;
    inp += inp << 16;
    inp ^= (inp >> 7) & 0x1FFFFFFu;
    inp ^= (inp >> 3) & 0x1FFFFFFFu;
    inp ^= inp << 6;
    inp ^= (inp >> 17) & 0x7FFFu;
    return inp;
}

__constant float cluster_cutoffs[9] = {
    0.626220f, 0.932770f, 0.275454f,
    0.318558f, 0.240113f, 0.009190f,
    0.347661f, 0.731960f, 0.156391f
};

float try_encode(float4* texels, float4 texels_mean, bool has_alpha, int dual_plane_component,
uint4* ep_ise, uint4* wt_ise, short3* best_blockmode) {
    float errval;
    if (has_alpha) {
        *best_blockmode = (short3)(QUANT_6, QUANT_256, 6);
    } else {
        *best_blockmode = (short3)(QUANT_12, QUANT_256, 12);
    }
    short weight_quantmethod = (*best_blockmode).x;
    short endpoint_quantmethod = (*best_blockmode).y;
    short weight_range = (*best_blockmode).z;

    float4 ep0, ep1;
    max_accumulation_pixel_direction(texels, texels_mean, &ep0, &ep1, has_alpha);

    *ep_ise = endpoint_ise(&ep0, &ep1, endpoint_quantmethod, has_alpha);
    *wt_ise = weight_ise(texels, weight_range - 1u, ep0, ep1, weight_quantmethod, &errval);
    return errval;
}

uint4 encode_block(float4* texels, float4 texels_mean,
    int blockID, __global PartInfo* global_parts, __global uint* errs)
{
    bool has_alpha = true;
    bool is_dual_plane = false;
    float errval = 10000000.0f;
    float tmp_err_val;
    int part_count = 1;
    int part_index = 0;

    uint4 ep_ise, wt_ise, tmp_ep_ise, tmp_wt_ise;
    short3 best_blockmode, tmp_best_blockmode;
    float threshhold = 10000.0f;
    errval = try_encode(texels, texels_mean,
        has_alpha, 0, &ep_ise, &wt_ise, &best_blockmode);

    uint blockmode = assemble_blockmode(best_blockmode.x, is_dual_plane);
    uint color_endpoint_mode;
    if (has_alpha) {
        color_endpoint_mode = CEM_LDR_RGBA_DIRECT;
    } else {
        color_endpoint_mode = CEM_LDR_RGB_DIRECT;
    }
    errs[blockID] = (uint)(errval);
    return
        assemble_block(blockmode, color_endpoint_mode, (uint)(part_count), (uint)(part_index), ep_ise, wt_ise);
}

kernel void astc(read_only image2d_t inputImage, __global uint4* astc_arr,
    __global PartInfo* global_parts, __global uint* errs) {
    int uWidth = get_global_size(0);
    int uHeight = get_global_size(1);
    const int2 local_id = (int2) (get_local_id(0), get_local_id(1));
    if (local_id.x == 0 && local_id.y == 0) {
        const int2 pos = (int2)(get_global_id(0), get_global_id(1));
        const int2 group = (int2)(get_group_id(0), get_group_id(1));
        int BlockNumX = (uWidth + DIM - 1)/DIM;
        int BlockNumY = (uHeight + DIM - 1)/DIM;

        int BlockID = group.y * BlockNumX + group.x;
        float4 texels[BLOCK_SIZE];
        float4 texel_mean = (float4)(0);
        for (int i = 0; i < DIM; ++i) {
            for (int j = 0; j < DIM; ++j) {
                int2 pixelPos = pos + (int2)(j, i);
                if (pixelPos.x > uWidth || pixelPos.y > uHeight) {
                    texels[i * DIM + j] = (float4)(255.0f);
                    continue;
                }
                float4 texel = read_imagef(inputImage, pixelPos);
                texels[i * DIM + j] = texel * 255.0f;
                texel_mean += texel * 255.0f;
            }
        }
        texel_mean = texel_mean / (float)(BLOCK_SIZE);
        astc_arr[BlockID] = encode_block(texels, texel_mean, BlockID, global_parts, errs);
    }
}
)";

std::shared_ptr<ImageCompressor> ImageCompressor::instance_ = nullptr;
std::mutex ImageCompressor::instanceMutex_;
std::shared_ptr<ImageCompressor> ImageCompressor::GetInstance()
{
    if (instance_ == nullptr) {
        std::lock_guard<std::mutex> lock(instanceMutex_);
        if (instance_ == nullptr) {
            instance_.reset(new ImageCompressor());
            instance_->Init();
        }
    }
    return instance_;
}

void ImageCompressor::Init()
{
    switch_  = true;
    if (switch_) {
        clOk_ = OHOS::InitOpenCL();
        if (!clOk_) {
            HiLog::Error(LABEL, "InitOpenCL error !");
        }
        InitPartition();
    }
}

bool ImageCompressor::CanCompress()
{
#ifdef UPLOAD_GPU_DISABLED
    return false;
#else
    return switch_ && clOk_;
#endif
}

cl_program ImageCompressor::LoadShader(cl_context context)
{
    cl_int err;
    sourceSize_ = strlen(g_programSource) + 1;
    cl_program p = clCreateProgramWithSource(context, 1, &g_programSource, &sourceSize_, &err);
    if (err || (!p)) {
        HiLog::Error(LABEL, "clCreateProgramWithSource error !");
        return nullptr;
    }
    return p;
}

std::string ImageCompressor::ReadSourceCode(const char *fileName)
{
    if (fileName == nullptr) {
        HiLog::Error(LABEL, "fileName is null!");
        return "";
    }

    std::fstream file(fileName, (std::fstream::in | std::fstream::binary));
    if (!file.is_open()) {
        HiLog::Error(LABEL, "Failed to open file: %s", fileName);
        return "";
    }

    std::string content;
    file.seekg(0, std::fstream::end);
    content.resize(file.tellg());
    file.seekg(0, std::fstream::beg);

    file.read(&content[0], content.size());
    file.close();

    sourceSize_ = content.size();
    return content;
}

bool ImageCompressor::CreateKernel()
{
    if (!context_ || !kernel_) {
        cl_int err;
        cl_platform_id platform_id;
        cl_device_id device_id;
        clGetPlatformIDs(1, &platform_id, NULL);
        if (!platform_id) {
            HiLog::Error(LABEL, "clGetPlatformIDs err!");
            return false;
        }
        clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_GPU, 1, &device_id, NULL);
        if (!device_id) {
            HiLog::Error(LABEL, "clGetDeviceIDs error!");
            return false;
        }
        context_ = clCreateContext(0, 1, &device_id, NULL, NULL, &err);
        if (!context_) {
            HiLog::Error(LABEL, "clCreateContext error %{public}d !", err);
        }
        queue_ = clCreateCommandQueueWithProperties(context_, device_id, 0, &err);
        if (!queue_) {
            HiLog::Error(LABEL, "clCreateCommandQueueWithProperties error %{public}d !", err);
        }
        cl_program program = LoadShader(context_);
        if (!program) {
            HiLog::Error(LABEL, "LoadShaderBin error !");
        }
        clBuildProgram(program, 1, &device_id, compileOption_.c_str(), NULL, NULL);
        kernel_ = clCreateKernel(program, "astc", &err);
        if (!kernel_) {
            HiLog::Error(LABEL, "clCreateKernel error %{public}d !", err);
        }
        clReleaseProgram(program);
    }
    if (!context_ || !kernel_ || !queue_) {
        ReleaseResource();
        HiLog::Error(LABEL, "build opencl program failed !");
        clOk_ = false;
        return false;
    }
    refCount_++;
    return true;
}

void ImageCompressor::ReleaseResource()
{
    clReleaseKernel(kernel_);
    kernel_ = NULL;
    clReleaseCommandQueue(queue_);
    queue_ = NULL;
    clReleaseContext(context_);
    context_ = NULL;
    instance_ = nullptr;
}

void ImageCompressor::GenAstcHeader(uint8_t *buffer, uint8_t blockX, uint8_t blockY, uint32_t dimX, uint32_t dimY)
{
    if (buffer == nullptr) {
        HiLog::Error(LABEL, "GenAstcHeader buffer is null");
        return;
    }
    uint8_t *headInfo = buffer;
    *headInfo++ = MAGIC_FILE_CONSTANT & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_8BITS) & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_16BITS) & BYTES_MASK;
    *headInfo++ = (MAGIC_FILE_CONSTANT >> BIT_SHIFT_24BITS) & BYTES_MASK;
    *headInfo++ = static_cast<uint8_t>(blockX);
    *headInfo++ = static_cast<uint8_t>(blockY);
    *headInfo++ = 1;
    *headInfo++ = dimX & BYTES_MASK;
    *headInfo++ = (dimX >> BIT_SHIFT_8BITS)& BYTES_MASK;
    *headInfo++ = (dimX >> BIT_SHIFT_16BITS)& BYTES_MASK;
    *headInfo++ = dimY & BYTES_MASK;
    *headInfo++ = (dimY >> BIT_SHIFT_8BITS)& BYTES_MASK;
    *headInfo++ = (dimY >> BIT_SHIFT_16BITS)& BYTES_MASK;
    *headInfo++ = 1 & BYTES_MASK;
    *headInfo++ = (1 >> BIT_SHIFT_8BITS) & BYTES_MASK;
    *headInfo++ = (1 >> BIT_SHIFT_16BITS) & BYTES_MASK;
}

void GetMaxAndSumVal(int32_t &numBlocks, uint32_t *blockErrs, uint32_t &max_val, uint32_t &sum_val)
{
    for (int32_t i = 0; i < numBlocks; i++) {
        sum_val += blockErrs[i];
        max_val = fmax(max_val, blockErrs[i]);
    }
}

bool ImageCompressor::TextureEncodeCL(uint8_t *data, int32_t strideIn, int32_t width, int32_t height, uint8_t *buffer)
{
    int32_t stride = strideIn >> STRIDE_RGBA_LOG2;
    std::lock_guard<std::mutex> lock(instanceMutex_);
    if (!clOk_ || width <= 0 || height <= 0 || !buffer || !data || (stride < width)) {
        HiLog::Error(LABEL, "TextureEncodeCL input parameters error");
        return  false;
    }
    GenAstcHeader(buffer, DIM, DIM, width, height);
    cl_int err;
    int32_t blockX = (width + DIM - 1) / DIM;
    int32_t blockY = (height + DIM - 1) / DIM;
    int32_t numBlocks = blockX * blockY;
    size_t local[] = {DIM, DIM};

    size_t global[GLOBAL_WH_NUM_CL];
    global[0] = (width % local[0] == 0 ? width : (width + local[0] - width % local[0]));
    global[1] = (height % local[1] == 0 ? height : (height + local[1] - height % local[1]));

    size_t astc_size = numBlocks * DIM * DIM;

    cl_image_format image_format = { CL_RGBA, CL_UNORM_INT8 };
    cl_image_desc desc = { CL_MEM_OBJECT_IMAGE2D, stride, height };
    cl_mem inputImage =
        clCreateImage(context_, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, &image_format, &desc, data, &err);
    cl_mem astcResult = clCreateBuffer(context_, CL_MEM_ALLOC_HOST_PTR, astc_size, NULL, &err);
    cl_mem partInfos =
        clCreateBuffer(context_, CL_MEM_COPY_HOST_PTR, sizeof(PartInfo) * parts_.size(), &parts_[0], &err);

    uint32_t *blockErrs = new uint32_t[numBlocks] {0};
    if (!blockErrs) {
        HiLog::Error(LABEL, "TextureEncodeCL blockErrs new failed");
        return false;
    }
    cl_mem clErrs = clCreateBuffer(context_, CL_MEM_USE_HOST_PTR, sizeof(uint32_t) * numBlocks, blockErrs, &err);

    int32_t kernelId = 0;
    err |= clSetKernelArg(kernel_, kernelId++, sizeof(cl_mem), &inputImage);
    err |= clSetKernelArg(kernel_, kernelId++, sizeof(cl_mem), &astcResult);
    err |= clSetKernelArg(kernel_, kernelId++, sizeof(cl_mem), &partInfos);
    err |= clSetKernelArg(kernel_, kernelId++, sizeof(cl_mem), &clErrs);

    err = clEnqueueNDRangeKernel(queue_, kernel_, GLOBAL_WH_NUM_CL, NULL, global, local, 0, NULL, NULL);

    clFinish(queue_);

    uint32_t max_val = 0, sum_val = 0;
    err = clEnqueueReadBuffer(queue_, clErrs, CL_TRUE, 0, sizeof(uint32_t) * numBlocks, blockErrs, 0, NULL, NULL);
    GetMaxAndSumVal(numBlocks, blockErrs, max_val, sum_val);
    clReleaseMemObject(inputImage);
    clReleaseMemObject(partInfos);
    clReleaseMemObject(clErrs);
    delete[] blockErrs;

    clEnqueueReadBuffer(queue_, astcResult, CL_TRUE, 0, astc_size, buffer + TEXTURE_HEAD_BYTES, 0, NULL, NULL);
    clReleaseMemObject(astcResult);

    return true;
}

std::function<void()> ImageCompressor::ScheduleReleaseTask()
{
    std::function<void()> task = [this]() {
        if (refCount_ > 0 && clOk_) {
            refCount_--;
            if (refCount_ <= 0) {
                this->ReleaseResource();

                std::ofstream saveFile(recordsPath_);
                if (!saveFile.is_open()) {
                    HiLog::Error(LABEL, "ScheduleReleaseTask saveFile is_open failed");
                    return;
                }
                std::lock_guard<std::mutex> mLock(recordsMutex_);
                for (auto s : failedRecords_) {
                    saveFile << s << "\n";
                }
                saveFile.close();
            }
        }
    };
    return task;
}

bool ImageCompressor::InitPartitionInfo(PartInfo *partInfos, int32_t part_index, int32_t part_count)
{
    if (partInfos == nullptr) {
        HiLog::Error(LABEL, "InitPartitionInfo partInfos is nullptr");
        return false;
    }
    int32_t texIdx = 0;
    int32_t counts[PARTITION_COUNT_4] = {0};
    for (int32_t y = 0; y < DIM; y++) {
        for (int32_t x = 0; x < DIM; x++) {
            int32_t part = AstcUtils::SelectPartition(part_index, x, y, part_count, true);
            partInfos->bitmaps[part] |= 1u << texIdx;
            counts[part]++;
            texIdx++;
        }
    }
    int32_t realPartCount = 0;
    if (counts[0] == 0) {
        realPartCount = 0;
    } else if (counts[1] == 0) {
        realPartCount = 1;
    } else if (counts[PARTITION_COUNT_2] == 0) {
        realPartCount = PARTITION_COUNT_2;
    } else if (counts[PARTITION_COUNT_3] == 0) {
        realPartCount = PARTITION_COUNT_3;
    } else {
        realPartCount = PARTITION_COUNT_4;
    }
    if (realPartCount == part_count) {
        return true;
    }
    return false;
}

void ImageCompressor::InitPartition()
{
    parts_.clear();
    int32_t arrSize = sizeof(partitions_) / sizeof(partitions_[0]);
    for (int32_t i = 0; i < arrSize; i++) {
        PartInfo p = {};
        if (InitPartitionInfo(&p, partitions_[i], PARTITION_COUNT_2)) {
            p.partid = partitions_[i];
            parts_.push_back(p);
        }
    }
    compileOption_ = "-D PARTITION_SERACH_MAX=" + std::to_string(parts_.size());
}
} // namespace Media
} // namespace OHOS