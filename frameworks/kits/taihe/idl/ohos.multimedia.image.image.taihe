/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.multimedia.image", "image")
@!sts_export_default
@!sts_inject("""
static { loadLibrary("image_taihe_core.z"); }
""")

enum PixelMapFormat: i32 {
  UNKNOWN = 0,
  ARGB_8888 = 1,
  RGB_565 = 2,
  RGBA_8888 = 3,
  BGRA_8888 = 4,
  RGB_888 = 5,
  ALPHA_8 = 6,
  RGBA_F16 = 7,
  NV21 = 8,
  NV12 = 9,
  RGBA_1010102 = 10,
  YCBCR_P010 = 11,
  YCRCB_P010 = 12,
  ASTC_4x4 = 102
}

enum ResolutionQuality: i32 {
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3
}

struct Size {
  width: i32;
  height: i32;
}

enum PropertyKey: String {
  BITS_PER_SAMPLE = "BitsPerSample",
  ORIENTATION = "Orientation",
  IMAGE_LENGTH = "ImageLength",
  IMAGE_WIDTH = "ImageWidth",
  GPS_LATITUDE = "GPSLatitude",
  GPS_LONGITUDE = "GPSLongitude",
  GPS_LATITUDE_REF = "GPSLatitudeRef",
  GPS_LONGITUDE_REF = "GPSLongitudeRef",
  DATE_TIME_ORIGINAL = "DateTimeOriginal",
  EXPOSURE_TIME = "ExposureTime",
  SCENE_TYPE = "SceneType",
  ISO_SPEED_RATINGS = "ISOSpeedRatings",
  F_NUMBER = "FNumber",
  DATE_TIME = "DateTime",
  GPS_TIME_STAMP = "GPSTimeStamp",
  GPS_DATE_STAMP = "GPSDateStamp",
  IMAGE_DESCRIPTION = "ImageDescription",
  MAKE = "Make",
  MODEL = "Model",
  PHOTO_MODE = "PhotoMode",
  SENSITIVITY_TYPE = "SensitivityType",
  STANDARD_OUTPUT_SENSITIVITY = "StandardOutputSensitivity",
  RECOMMENDED_EXPOSURE_INDEX = "RecommendedExposureIndex",
  ISO_SPEED = "ISOSpeedRatings",
  APERTURE_VALUE = "ApertureValue",
  EXPOSURE_BIAS_VALUE = "ExposureBiasValue",
  METERING_MODE = "MeteringMode",
  LIGHT_SOURCE = "LightSource",
  FLASH = "Flash",
  FOCAL_LENGTH = "FocalLength",
  USER_COMMENT = "UserComment",
  PIXEL_X_DIMENSION = "PixelXDimension",
  PIXEL_Y_DIMENSION = "PixelYDimension",
  WHITE_BALANCE = "WhiteBalance",
  FOCAL_LENGTH_IN_35_MM_FILM = "FocalLengthIn35mmFilm",
  CAPTURE_MODE = "HwMnoteCaptureMode",
  PHYSICAL_APERTURE = "HwMnotePhysicalAperture",
  ROLL_ANGLE = "HwMnoteRollAngle",
  PITCH_ANGLE = "HwMnotePitchAngle",
  SCENE_FOOD_CONF = "HwMnoteSceneFoodConf",
  SCENE_STAGE_CONF = "HwMnoteSceneStageConf",
  SCENE_BLUE_SKY_CONF = "HwMnoteSceneBlueSkyConf",
  SCENE_GREEN_PLANT_CONF = "HwMnoteSceneGreenPlantConf",
  SCENE_BEACH_CONF = "HwMnoteSceneBeachConf",
  SCENE_SNOW_CONF = "HwMnoteSceneSnowConf",
  SCENE_SUNSET_CONF = "HwMnoteSceneSunsetConf",
  SCENE_FLOWERS_CONF = "HwMnoteSceneFlowersConf",
  SCENE_NIGHT_CONF = "HwMnoteSceneNightConf",
  SCENE_TEXT_CONF = "HwMnoteSceneTextConf",
  FACE_COUNT = "HwMnoteFaceCount",
  FOCUS_MODE = "HwMnoteFocusMode",
  COMPRESSION = "Compression",
  PHOTOMETRIC_INTERPRETATION = "PhotometricInterpretation",
  STRIP_OFFSETS = "StripOffsets",
  SAMPLES_PER_PIXEL = "SamplesPerPixel",
  ROWS_PER_STRIP = "RowsPerStrip",
  STRIP_BYTE_COUNTS = "StripByteCounts",
  X_RESOLUTION = "XResolution",
  Y_RESOLUTION = "YResolution",
  PLANAR_CONFIGURATION = "PlanarConfiguration",
  RESOLUTION_UNIT = "ResolutionUnit",
  TRANSFER_FUNCTION = "TransferFunction",
  SOFTWARE = "Software",
  ARTIST = "Artist",
  WHITE_POINT = "WhitePoint",
  PRIMARY_CHROMATICITIES = "PrimaryChromaticities",
  YCBCR_COEFFICIENTS = "YCbCrCoefficients",
  YCBCR_SUB_SAMPLING = "YCbCrSubSampling",
  YCBCR_POSITIONING = "YCbCrPositioning",
  REFERENCE_BLACK_WHITE = "ReferenceBlackWhite",
  COPYRIGHT = "Copyright",
  JPEG_INTERCHANGE_FORMAT = "JPEGInterchangeFormat",
  JPEG_INTERCHANGE_FORMAT_LENGTH = "JPEGInterchangeFormatLength",
  EXPOSURE_PROGRAM = "ExposureProgram",
  SPECTRAL_SENSITIVITY = "SpectralSensitivity",
  OECF = "OECF",
  EXIF_VERSION = "ExifVersion",
  DATE_TIME_DIGITIZED = "DateTimeDigitized",
  COMPONENTS_CONFIGURATION = "ComponentsConfiguration",
  SHUTTER_SPEED = "ShutterSpeedValue",
  BRIGHTNESS_VALUE = "BrightnessValue",
  MAX_APERTURE_VALUE = "MaxApertureValue",
  SUBJECT_DISTANCE = "SubjectDistance",
  SUBJECT_AREA = "SubjectArea",
  MAKER_NOTE = "MakerNote",
  SUBSEC_TIME = "SubsecTime",
  SUBSEC_TIME_ORIGINAL = "SubsecTimeOriginal",
  SUBSEC_TIME_DIGITIZED = "SubsecTimeDigitized",
  FLASHPIX_VERSION = "FlashpixVersion",
  COLOR_SPACE = "ColorSpace",
  RELATED_SOUND_FILE = "RelatedSoundFile",
  FLASH_ENERGY = "FlashEnergy",
  SPATIAL_FREQUENCY_RESPONSE = "SpatialFrequencyResponse",
  FOCAL_PLANE_X_RESOLUTION = "FocalPlaneXResolution",
  FOCAL_PLANE_Y_RESOLUTION = "FocalPlaneYResolution",
  FOCAL_PLANE_RESOLUTION_UNIT = "FocalPlaneResolutionUnit",
  SUBJECT_LOCATION = "SubjectLocation",
  EXPOSURE_INDEX = "ExposureIndex",
  SENSING_METHOD = "SensingMethod",
  FILE_SOURCE = "FileSource",
  CFA_PATTERN = "CFAPattern",
  CUSTOM_RENDERED = "CustomRendered",
  EXPOSURE_MODE = "ExposureMode",
  DIGITAL_ZOOM_RATIO = "DigitalZoomRatio",
  SCENE_CAPTURE_TYPE = "SceneCaptureType",
  GAIN_CONTROL = "GainControl",
  CONTRAST = "Contrast",
  SATURATION = "Saturation",
  SHARPNESS = "Sharpness",
  DEVICE_SETTING_DESCRIPTION = "DeviceSettingDescription",
  SUBJECT_DISTANCE_RANGE = "SubjectDistanceRange",
  IMAGE_UNIQUE_ID = "ImageUniqueID",
  GPS_VERSION_ID = "GPSVersionID",
  GPS_ALTITUDE_REF = "GPSAltitudeRef",
  GPS_ALTITUDE = "GPSAltitude",
  GPS_SATELLITES = "GPSSatellites",
  GPS_STATUS = "GPSStatus",
  GPS_MEASURE_MODE = "GPSMeasureMode",
  GPS_DOP = "GPSDOP",
  GPS_SPEED_REF = "GPSSpeedRef",
  GPS_SPEED = "GPSSpeed",
  GPS_TRACK_REF = "GPSTrackRef",
  GPS_TRACK = "GPSTrack",
  GPS_IMG_DIRECTION_REF = "GPSImgDirectionRef",
  GPS_IMG_DIRECTION = "GPSImgDirection",
  GPS_MAP_DATUM = "GPSMapDatum",
  GPS_DEST_LATITUDE_REF = "GPSDestLatitudeRef",
  GPS_DEST_LATITUDE = "GPSDestLatitude",
  GPS_DEST_LONGITUDE_REF = "GPSDestLongitudeRef",
  GPS_DEST_LONGITUDE = "GPSDestLongitude",
  GPS_DEST_BEARING_REF = "GPSDestBearingRef",
  GPS_DEST_BEARING = "GPSDestBearing",
  GPS_DEST_DISTANCE_REF = "GPSDestDistanceRef",
  GPS_DEST_DISTANCE = "GPSDestDistance",
  GPS_PROCESSING_METHOD = "GPSProcessingMethod",
  GPS_AREA_INFORMATION = "GPSAreaInformation",
  GPS_DIFFERENTIAL = "GPSDifferential",
  BODY_SERIAL_NUMBER = "BodySerialNumber",
  CAMERA_OWNER_NAME = "CameraOwnerName",
  COMPOSITE_IMAGE = "CompositeImage",
  COMPRESSED_BITS_PER_PIXEL = "CompressedBitsPerPixel",
  DNG_VERSION = "DNGVersion",
  DEFAULT_CROP_SIZE = "DefaultCropSize",
  GAMMA = "Gamma",
  ISO_SPEED_LATITUDE_YYY = "ISOSpeedLatitudeyyy",
  ISO_SPEED_LATITUDE_ZZZ = "ISOSpeedLatitudezzz",
  LENS_MAKE = "LensMake",
  LENS_MODEL = "LensModel",
  LENS_SERIAL_NUMBER = "LensSerialNumber",
  LENS_SPECIFICATION = "LensSpecification",
  NEW_SUBFILE_TYPE = "NewSubfileType",
  OFFSET_TIME = "OffsetTime",
  OFFSET_TIME_DIGITIZED = "OffsetTimeDigitized",
  OFFSET_TIME_ORIGINAL = "OffsetTimeOriginal",
  SOURCE_EXPOSURE_TIMES_OF_COMPOSITE_IMAGE = "SourceExposureTimesOfCompositeImage",
  SOURCE_IMAGE_NUMBER_OF_COMPOSITE_IMAGE = "SourceImageNumberOfCompositeImage",
  SUBFILE_TYPE = "SubfileType",
  GPS_H_POSITIONING_ERROR = "GPSHPositioningError",
  PHOTOGRAPHIC_SENSITIVITY = "PhotographicSensitivity",
  BURST_NUMBER = "HwMnoteBurstNumber",
  FACE_CONF = "HwMnoteFaceConf",
  FACE_LEYE_CENTER = "HwMnoteFaceLeyeCenter",
  FACE_MOUTH_CENTER = "HwMnoteFaceMouthCenter",
  FACE_POINTER = "HwMnoteFacePointer",
  FACE_RECT = "HwMnoteFaceRect",
  FACE_REYE_CENTER = "HwMnoteFaceReyeCenter",
  FACE_SMILE_SCORE = "HwMnoteFaceSmileScore",
  FACE_VERSION = "HwMnoteFaceVersion",
  FRONT_CAMERA = "HwMnoteFrontCamera",
  SCENE_POINTER = "HwMnoteScenePointer",
  SCENE_VERSION = "HwMnoteSceneVersion",
  IS_XMAGE_SUPPORTED = "HwMnoteIsXmageSupported",
  XMAGE_MODE = "HwMnoteXmageMode",
  XMAGE_LEFT = "HwMnoteXmageLeft",
  XMAGE_TOP = "HwMnoteXmageTop",
  XMAGE_RIGHT = "HwMnoteXmageRight",
  XMAGE_BOTTOM = "HwMnoteXmageBottom",
  CLOUD_ENHANCEMENT_MODE = "HwMnoteCloudEnhancementMode",
  WIND_SNAPSHOT_MODE = "HwMnoteWindSnapshotMode",
  GIF_LOOP_COUNT = "GIFLoopCount"
}

enum ImageFormat: i32 {
  YCBCR_422_SP = 1000,
  JPEG = 2000
}

enum AlphaType: i32 {
  UNKNOWN = 0,
  OPAQUE = 1,
  PREMUL = 2,
  UNPREMUL = 3
}

enum DecodingDynamicRange: i32 {
  AUTO = 0,
  SDR = 1,
  HDR = 2
}

enum PackingDynamicRange: i32 {
  AUTO = 0,
  SDR = 1,
}

enum AntiAliasingLevel: i32 {
  NONE = 0,
  LOW = 1,
  MEDIUM = 2,
  HIGH = 3
}

enum ScaleMode: i32 {
  FIT_TARGET_SIZE = 0,
  CENTER_CROP = 1
}

enum ComponentType: i32 {
  YUV_Y = 1,
  YUV_U = 2,
  YUV_V = 3,
  JPEG = 4
}

enum AllocatorType: i32 {
  AUTO = 0,
  DMA = 1,
  SHARE_MEMORY = 2,
}

struct Region {
  size: Size;
  x: i32;
  y: i32;
}

// Can't use struct because struct is copied instead of referenced, so data changes to "pixels" in C++ will not be reflected in ArkTS
interface PositionArea {
  @get GetPixels(): @arraybuffer Array<u8>;
  @set SetPixels(pixels: @arraybuffer Array<u8>): void;
  @get GetOffset(): i32;
  @set SetOffset(offset: i32): void;
  @get GetStride(): i32;
  @set SetStride(stride: i32): void;
  @get GetRegion(): Region;
  @set SetRegion(region: Region): void;
}

struct ImageInfo {
  size: Size;
  density: i32;
  stride: i32;
  pixelFormat: PixelMapFormat;
  alphaType: AlphaType;
  mimeType: String;
  isHdr: bool;
}

enum CropAndScaleStrategy: i32 {
  SCALE_FIRST = 1,
  CROP_FIRST = 2
}

struct PackingOption {
  format: String;
  quality: i32;
  bufferSize: Optional<i32>;
  desiredDynamicRange: Optional<PackingDynamicRange>;
  needsPackProperties: Optional<bool>;
}

struct PackingOptionsForSequence {
  frameCount: i32;
  delayTimeList: Array<i32>;
  disposalTypes: Optional<Array<i32>>;
  loopCount: Optional<i32>;
}

struct ImagePropertyOptions {
  index: Optional<i32>;
  defaultValue: Optional<String>;
}

struct DecodingOptions {
  index: Optional<i32>;
  sampleSize: Optional<i32>;
  rotate: Optional<i32>;
  editable: Optional<bool>;
  desiredSize: Optional<Size>;
  desiredRegion: Optional<Region>;
  desiredPixelFormat: Optional<PixelMapFormat>;
  photoDesiredPixelFormat: Optional<PixelMapFormat>; // not exposed to the user
  fitDensity: Optional<i32>;
  fillColor: Optional<i32>; // not exposed to the user
  SVGResize: Optional<i32>; // not exposed to the user
  desiredColorSpace: Optional<@sts_type("colorSpaceManager.ColorSpaceManager") Opaque>;
  desiredDynamicRange: Optional<DecodingDynamicRange>;
  resolutionQuality: Optional<ResolutionQuality>;
  cropAndScaleStrategy: Optional<CropAndScaleStrategy>;
  reusePixelmap: Optional<PixelMap>; // not exposed to the user
}

struct Component {
  @readonly componentType: ComponentType;
  @readonly rowStride: i32;
  @readonly pixelStride: i32;
  @readonly byteBuffer: @arraybuffer Array<u8>;
}

struct InitializationOptions {
  size: Size;
  srcPixelFormat: Optional<PixelMapFormat>;
  pixelFormat: Optional<PixelMapFormat>;
  editable: Optional<bool>;
  alphaType: Optional<AlphaType>;
  scaleMode: Optional<ScaleMode>;
}

struct SourceOptions {
  sourceDensity: i32;
  sourcePixelFormat: Optional<PixelMapFormat>;
  sourceSize: Optional<Size>;
}

struct HdrStaticMetadata {
  displayPrimariesX: Array<f64>;
  displayPrimariesY: Array<f64>;
  whitePointX: f64;
  whitePointY: f64;
  maxLuminance: f64;
  minLuminance: f64;
  maxContentLightLevel: f64;
  maxFrameAverageLightLevel: f64;
}

struct GainmapChannel {
  gainmapMax: f64;
  gainmapMin: f64;
  gamma: f64;
  baseOffset: f64;
  alternateOffset: f64;
}

struct HdrGainmapMetadata {
  writerVersion: i32;
  miniVersion: i32;
  gainmapChannelCount: i32;
  useBaseColorFlag: bool;
  baseHeadroom: f64;
  alternateHeadroom: f64;
  channels: Array<GainmapChannel>;
}

enum HdrMetadataKey: i32 {
  HDR_METADATA_TYPE = 0,
  HDR_STATIC_METADATA = 1,
  HDR_DYNAMIC_METADATA = 2,
  HDR_GAINMAP_METADATA = 3,
}

enum HdrMetadataType: i32 {
  NONE = 0,
  BASE = 1,
  GAINMAP = 2,
  ALTERNATE = 3,
}

enum AuxiliaryPictureType: i32 {
  GAINMAP = 1,
  DEPTH_MAP = 2,
  UNREFOCUS_MAP = 3,
  LINEAR_MAP = 4,
  FRAGMENT_MAP = 5,
}

enum MetadataType: i32 {
  EXIF_METADATA = 1,
  FRAGMENT_METADATA = 2,
}

enum FragmentMapPropertyKey: String {
  X_IN_ORIGINAL = "XInOriginal",
  Y_IN_ORIGINAL = "YInOriginal",
  WIDTH = "FragmentImageWidth",
  HEIGHT = "FragmentImageHeight"
}

struct DecodingOptionsForPicture {
  desiredAuxiliaryPictures: Array<AuxiliaryPictureType>;
}

struct AuxiliaryPictureInfo {
  auxiliaryPictureType: AuxiliaryPictureType;
  size: Size;
  rowStride: i32;
  pixelFormat: PixelMapFormat;
  colorSpace: @sts_type("colorSpaceManager.ColorSpaceManager") Opaque;
}

union HdrMetadataValue {
  hdrMetadataType: HdrMetadataType;
  hdrStaticMetadata: HdrStaticMetadata;
  arrayBuffer: @arraybuffer Array<u8>;
  hdrGainmapMetadata: HdrGainmapMetadata;
}

union PropertyValue {
    type_string: String;
    @null type_null;
}

interface PixelMap {
  GetImplPtr(): i64;

  @gen_async("getImageInfo")
  @gen_promise("getImageInfo")
  GetImageInfoSync(): ImageInfo;

  @gen_async("readPixelsToBuffer")
  @gen_promise("readPixelsToBuffer")
  ReadPixelsToBufferSync(dst: @arraybuffer Array<u8>): void;

  @gen_async("readPixels")
  @gen_promise("readPixels")
  ReadPixelsSync(area: PositionArea): void;

  @gen_async("writeBufferToPixels")
  @gen_promise("writeBufferToPixels")
  WriteBufferToPixelsSync(src: @arraybuffer Array<u8>): void;

  @gen_async("writePixels")
  @gen_promise("writePixels")
  WritePixelsSync(area: PositionArea): void;

  @gen_async("createAlphaPixelmap")
  @gen_promise("createAlphaPixelmap")
  CreateAlphaPixelmapSync(): PixelMap;

  GetBytesNumberPerRow(): i32;

  GetPixelBytesNumber(): i32;

  GetDensity(): i32;

  @gen_async("scale")
  @gen_promise("scale")
  @overload("scaleSync")
  ScaleSync(x: f64, y: f64): void;

  @gen_promise("scale")
  @overload("scaleSync")
  ScaleWithAntiAliasingSync(x: f64, y: f64, level: AntiAliasingLevel): void;

  @gen_promise("createScaledPixelMap")
  CreateScaledPixelMapSync(x: f64, y: f64, level: Optional<AntiAliasingLevel>): PixelMap;

  @gen_promise("clone")
  CloneSync(): PixelMap;

  @gen_async("translate")
  @gen_promise("translate")
  TranslateSync(x: f64, y: f64): void;

  @gen_async("crop")
  @gen_promise("crop")
  CropSync(region: Region): void;

  @gen_async("rotate")
  @gen_promise("rotate")
  RotateSync(angle: f64): void;

  @gen_async("flip")
  @gen_promise("flip")
  FlipSync(horizontal: bool, vertical: bool): void;

  @gen_async("opacity")
  @gen_promise("opacity")
  OpacitySync(rate: f64): void;

  @gen_promise("toSdr")
  ToSdrSync(): void;

  @gen_async("applyColorSpace")
  @gen_promise("applyColorSpace")
  ApplyColorSpaceSync(targetColorSpace: @sts_type("colorSpaceManager.ColorSpaceManager") Opaque): void;

  SetMemoryNameSync(name: String): void;

  SetTransferDetached(detached: bool): void;

  @gen_promise("convertPixelFormat")
  ConvertPixelFormatSync(targetPixelFormat: PixelMapFormat): void;

  GetColorSpace(): @sts_type("colorSpaceManager.ColorSpaceManager") Opaque;

  SetColorSpace(colorSpace: @sts_type("colorSpaceManager.ColorSpaceManager") Opaque): void;

  Marshalling(sequence: @sts_type("rpc.MessageSequence") Opaque): void;

  @gen_promise("unmarshalling")
  UnmarshallingSync(sequence: @sts_type("rpc.MessageSequence") Opaque): PixelMap;

  GetMetadata(key: HdrMetadataKey): HdrMetadataValue;

  @gen_promise("setMetadata")
  SetMetadataSync(key: HdrMetadataKey, value: HdrMetadataValue): void;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;

  @get GetIsEditable(): bool;

  @get GetIsStrideAlignment(): bool;

  @set SetCaptureId(captureId: i32): void;
  @get GetCaptureId(): i32;

  @set SetTimestamp(timestamp: i64): void;
  @get GetTimestamp(): i64;
}

union GainMap {
    type_gainMap: PixelMap;
    @null type_null;
}

union AuxPicture {
    type_auxPicture: AuxiliaryPicture;
    @null type_null;
}

interface Picture {
  GetImplPtr(): i64;

  GetMainPixelmap(): Optional<PixelMap>;

  @gen_promise("getHdrComposedPixelmap")
  GetHdrComposedPixelmapSync(): Optional<PixelMap>;

  GetGainmapPixelmap(): GainMap;

  SetAuxiliaryPicture(type: AuxiliaryPictureType, auxiliaryPicture: AuxiliaryPicture): void;

  GetAuxiliaryPicture(type: AuxiliaryPictureType): AuxPicture;

  @gen_promise("setMetadata")
  SetMetadataSync(metadataType: MetadataType, metadata: Metadata): void;

  @gen_promise("getMetadata")
  GetMetadataSync(metadataType: MetadataType): Optional<Metadata>;

  Marshalling(sequence: @sts_type("rpc.MessageSequence") Opaque): void;

  Release(): void;
}

interface AuxiliaryPicture {
  GetImplPtr(): i64;

  @gen_promise("writePixelsFromBuffer")
  WritePixelsFromBufferSync(data: @arraybuffer Array<u8>): void;

  @gen_promise("readPixelsToBuffer")
  ReadPixelsToBufferSync(): Optional<@arraybuffer Array<u8>>;

  GetType(): Optional<AuxiliaryPictureType>;

  @gen_promise("setMetadata")
  SetMetadataSync(metadataType: MetadataType, metadata: Metadata): void;

  @gen_promise("getMetadata")
  GetMetadataSync(metadataType: MetadataType): Optional<Metadata>;

  GetAuxiliaryPictureInfo(): Optional<AuxiliaryPictureInfo>;

  SetAuxiliaryPictureInfo(info: AuxiliaryPictureInfo): void;

  Release(): void;
}

interface Metadata {
  GetImplPtr(): i64;

  @gen_promise("getProperties")
  GetPropertiesSync(key: Array<String>): @record Map<String, PropertyValue>;

  @gen_promise("setProperties")
  SetPropertiesSync(records: @record Map<String, PropertyValue>): void;

  @gen_promise("getAllProperties")
  GetAllPropertiesSync(): Optional<@record Map<String, PropertyValue>>;
  
  @gen_promise("clone")
  CloneSync(): Optional<Metadata>;
}

interface ImageSource {
  GetImplPtr(): i64;

  @gen_async("getImageInfo")
  GetImageInfoWithIndexCallback(index: i32): Optional<ImageInfo>;

  @gen_async("getImageInfo")
  GetImageInfoWithCallback(): Optional<ImageInfo>;

  @gen_promise("getImageInfo")
  GetImageInfoReturnsPromise(index: Optional<i32>): Optional<ImageInfo>;

  GetImageInfoSync(index: Optional<i32>): Optional<ImageInfo>;

  @gen_async("createPixelMap")
  CreatePixelMapWithOptionsCallback(options: DecodingOptions): Optional<PixelMap>;
 
  @gen_async("createPixelMap")
  CreatePixelMapWithCallback(): Optional<PixelMap>;
 
  @gen_promise("createPixelMap")
  CreatePixelMapReturnsPromise(options: Optional<DecodingOptions>): Optional<PixelMap>;
 
  CreatePixelMapSync(options: Optional<DecodingOptions>): Optional<PixelMap>;

  @gen_promise("createPixelMapUsingAllocator")
  CreatePixelMapUsingAllocatorSync(options: Optional<DecodingOptions>, allocatorType: Optional<AllocatorType>): Optional<PixelMap>;

  @gen_async("createPixelMapList")
  CreatePixelMapListSync(): Array<PixelMap>;

  @gen_async("createPixelMapList")
  CreatePixelMapListSyncWithOptions(options: DecodingOptions): Array<PixelMap>;

  @gen_promise("createPixelMapList")
  CreatePixelMapListSyncWithOptionalOptions(options: Optional<DecodingOptions>): Array<PixelMap>;

  @gen_async("getDelayTimeList")
  @gen_promise("getDelayTimeList")
  GetDelayTimeListSync(): Array<i32>;

  @gen_promise("getDisposalTypeList")
  GetDisposalTypeListSync(): Array<i32>;

  @gen_async("getFrameCount")
  @gen_promise("getFrameCount")
  GetFrameCountSync(): i32;

  @gen_promise("getImageProperty")
  GetImagePropertySync(key: PropertyKey, options: Optional<ImagePropertyOptions>): String;

  @gen_promise("getImageProperties")
  GetImagePropertiesSync(key: Array<PropertyKey>): @record Map<PropertyKey, PropertyValue>;

  @gen_promise("modifyImageProperty")
  ModifyImagePropertySync(key: PropertyKey, value: String): void;
  
  @gen_promise("modifyImageProperties")
  ModifyImagePropertiesSync(records: @record Map<PropertyKey, PropertyValue>): void;

  @gen_async("updateData")
  @gen_promise("updateData")
  UpdateDataSync(buf: @arraybuffer Array<u8>, isFinished: bool, offset: i32, length: i32): void;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;

  @gen_promise("createPicture")
  CreatePictureSync(options: Optional<DecodingOptionsForPicture>): Optional<Picture>;

  @get GetSupportedFormats(): Array<String>;
}

interface ImagePacker {
  GetImplPtr(): i64;

  @gen_promise("packToData")
  PackImageSourceToDataSync(source: ImageSource, options: PackingOption): @arraybuffer Array<u8>;

  @gen_promise("packToData")
  PackPixelMapToDataSync(source: PixelMap, options: PackingOption): @arraybuffer Array<u8>;

  @gen_promise("packToDataFromPixelmapSequence")
  PackToDataFromPixelmapSequenceSync(pixelmapSequence: Array<PixelMap>, options: PackingOptionsForSequence): @arraybuffer Array<u8>;

  @gen_async("packToFile")
  @gen_promise("packToFile")
  PackImageSourceToFileSync(source: ImageSource, fd: i32, options: PackingOption): void;

  @gen_async("packToFile")
  @gen_promise("packToFile")
  PackPixelMapToFileSync(source: PixelMap, fd: i32, options: PackingOption): void;

  @gen_promise("packToFileFromPixelmapSequence")
  PackToFileFromPixelmapSequenceSync(pixelmapSequence: Array<PixelMap>, fd: i32, options: PackingOptionsForSequence): void;

  @gen_promise("packToFile")
  PackPictureToFileSync(picture: Picture, fd: i32, options: PackingOption): void;

  @gen_promise("packing")
  PackingPictureSync(picture: Picture, options: PackingOption): @arraybuffer Array<u8>;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;

  @get GetSupportedFormats(): Array<String>;
}

interface Image {
  @get("clipRect") GetClipRect(): Region;
  GetImplPtr(): i64;

  @get("size") GetSize(): Size;
  @get("format") GetFormat(): i32;
  @get("timestamp") GetTimestamp(): i64;

  @gen_async("getComponent")
  @gen_promise("getComponent")
  GetComponentSync(componentType: ComponentType): Component;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;
}

interface ImageReceiver {
  GetImplPtr(): i64;

  @get GetSize(): Size;
  @get GetCapacity(): i32;
  @get GetFormat(): ImageFormat;

  @gen_async("getReceivingSurfaceId")
  @gen_promise("getReceivingSurfaceId")
  GetReceivingSurfaceIdSync(): String;

  @gen_async("readLatestImage")
  @gen_promise("readLatestImage")
  ReadLatestImageSync(): Image;

  @gen_async("readNextImage")
  @gen_promise("readNextImage")
  ReadNextImageSync(): Image;

  OnImageArrival(callback: (err: @sts_type("BusinessError<void>") Opaque, data: @sts_type("undefined") Opaque)=> void): void;
  OffImageArrival(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque, data: @sts_type("undefined") Opaque)=> void>): void;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;
}

interface ImageCreator {
  GetImplPtr(): i64;

  @get("capacity") GetCapacity(): i32;
  @get("format") GetFormat(): ImageFormat;

  @gen_async("queueImage")
  @gen_promise("queueImage")
  QueueImageSync(image: Image): void;

  @gen_async("dequeueImage")
  @gen_promise("dequeueImage")
  DequeueImageSync(): Image;

  OnImageRelease(callback: (err: @sts_type("BusinessError<void>") Opaque, data: @sts_type("undefined") Opaque)=> void): void;
  OffImageRelease(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque, data: @sts_type("undefined") Opaque)=> void>): void;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;
}

// transfer functions
function ImageSourceTransferStaticImpl(input: @sts_type("ESValue") Opaque): ImageSource;
function ImageSourceTransferDynamicImpl(input: ImageSource): @sts_type("Any") Opaque;

function ImagePackerTransferStaticImpl(input: @sts_type("ESValue") Opaque): ImagePacker;
function ImagePackerTransferDynamicImpl(input: ImagePacker): @sts_type("Any") Opaque;

function PictureTransferStaticImpl(input: @sts_type("ESValue") Opaque): Picture;
function PictureTransferDynamicImpl(input: Picture): @sts_type("Any") Opaque;

function AuxiliaryPictureTransferStaticImpl(input: @sts_type("ESValue") Opaque): AuxiliaryPicture;
function AuxiliaryPictureTransferDynamicImpl(input: AuxiliaryPicture): @sts_type("Any") Opaque;

function ImageReceiverTransferStaticImpl(input: @sts_type("ESValue") Opaque): ImageReceiver;
function ImageReceiverTransferDynamicImpl(input: ImageReceiver): @sts_type("Any") Opaque;

function ImageCreatorTransferStaticImpl(input: @sts_type("ESValue") Opaque): ImageCreator;
function ImageCreatorTransferDynamicImpl(input: ImageCreator): @sts_type("Any") Opaque;

function PixelMapTransferStaticImpl(input: @sts_type("ESValue") Opaque): PixelMap;
function PixelMapTransferDynamicImpl(input: PixelMap): @sts_type("Any") Opaque;

@!sts_inject("""
export function imageSourceTransferStatic(input: Any): Object {
  return imageSourceTransferStaticImpl(ESValue.wrap(input));
}
export function imageSourceTransferDynamic(input: Object): Any {
  return imageSourceTransferDynamicImpl(input as ImageSource);
}

export function imagePackerTransferStatic(input: Any): Object {
  return imagePackerTransferStaticImpl(ESValue.wrap(input));
}
export function imagePackerTransferDynamic(input: Object): Any {
  return imagePackerTransferDynamicImpl(input as ImagePacker);
}

export function pictureTransferStatic(input: Any): Object {
  return pictureTransferStaticImpl(ESValue.wrap(input));
}
export function pictureTransferDynamic(input: Object): Any {
  return pictureTransferDynamicImpl(input as Picture);
}

export function auxiliaryPictureTransferStatic(input: Any): Object {
  return auxiliaryPictureTransferStaticImpl(ESValue.wrap(input));
}
export function auxiliaryPictureTransferDynamic(input: Object): Any {
  return auxiliaryPictureTransferDynamicImpl(input as AuxiliaryPicture);
}

export function imageReceiverTransferStatic(input: Any): Object {
  return imageReceiverTransferStaticImpl(ESValue.wrap(input));
}
export function imageReceiverTransferDynamic(input: Object): Any {
  return imageReceiverTransferDynamicImpl(input as ImageReceiver);
}

export function imageCreatorTransferStatic(input: Any): Object {
  return imageCreatorTransferStaticImpl(ESValue.wrap(input));
}
export function imageCreatorTransferDynamic(input: Object): Any {
  return imageCreatorTransferDynamicImpl(input as ImageCreator);
}

export function pixelMapTransferStatic(input: Any): Object {
  return pixelMapTransferStaticImpl(ESValue.wrap(input));
}
export function pixelMapTransferDynamic(input: Object): Any {
  return pixelMapTransferDynamicImpl(input as PixelMap);
}
""")

// global functions
function MakeEmptySize(): Size;
function MakeEmptyImageInfo(): ImageInfo;

@gen_async("createPixelMap")
@gen_promise("createPixelMap")
@overload("createPixelMapSync")
function CreatePixelMapByBufferAndOptionsSync(colors: @arraybuffer Array<u8>, options: InitializationOptions): PixelMap;

@overload("createPixelMapSync")
function CreatePixelMapByOptionsSync(options: InitializationOptions): PixelMap;

// For legacy ANI backward compatibility
function CreatePixelMapByPtr(ptr: i64): PixelMap;

@gen_promise("createPixelMapFromSurface")
@overload("createPixelMapFromSurfaceSync")
function CreatePixelMapFromSurfaceByIdSync(surfaceId: String): PixelMap;

@gen_promise("createPixelMapFromSurface")
@overload("createPixelMapFromSurfaceSync")
function CreatePixelMapFromSurfaceByIdAndRegionSync(surfaceId: String, region: Region): PixelMap;

function CreatePixelMapFromParcel(sequence: @sts_type("rpc.MessageSequence") Opaque): PixelMap;

@gen_async("createPremultipliedPixelMap")
@gen_promise("createPremultipliedPixelMap")
function CreatePremultipliedPixelMapSync(src: PixelMap, dst: PixelMap): void;

@gen_async("createUnpremultipliedPixelMap")
@gen_promise("createUnpremultipliedPixelMap")
function CreateUnpremultipliedPixelMapSync(src: PixelMap, dst: PixelMap): void;

@overload("createImageSource")
function CreateImageSourceByUri(uri: String): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByUriOption(uri: String, options: SourceOptions): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByFd(fd: i32): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByFdOption(fd: i32, options: SourceOptions): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByArrayBuffer(buf: @arraybuffer Array<u8>): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByArrayBufferOption(buf: @arraybuffer Array<u8>, options: SourceOptions): Optional<ImageSource>;

@overload("CreateIncrementalSource")
function CreateIncrementalSourceByArrayBuffer(buf: @arraybuffer Array<u8>): Optional<ImageSource>;

@overload("CreateIncrementalSource")
function CreateIncrementalSourceByArrayBufferOption(buf: @arraybuffer Array<u8>, options: Optional<SourceOptions>): Optional<ImageSource>;

@overload("createImageSource")
function CreateImageSourceByRawFileDescriptorOption(rawfile: @sts_type("resourceManager.RawFileDescriptor") Opaque, options: Optional<SourceOptions>): Optional<ImageSource>;

// For legacy ANI backward compatibility
function CreateImageSourceByPtr(ptr: i64): ImageSource;

function CreateImagePacker(): ImagePacker;

function CreateImageCreator(size: Size, format: ImageFormat, capacity: i32): ImageCreator;

function CreateImageReceiver(size: Size, format: ImageFormat, capacity: i32): Optional<ImageReceiver>;

@overload("createPicture")
function CreatePictureByPixelMap(mainPixelmap : PixelMap): Picture;

// For legacy ANI backward compatibility
function CreatePictureByPtr(ptr: i64): Picture;

function CreatePictureFromParcel(sequence: @sts_type("rpc.MessageSequence") Opaque): Picture;

function CreateAuxiliaryPicture(buffer: @arraybuffer Array<u8>, size: Size, type: AuxiliaryPictureType): AuxiliaryPicture;